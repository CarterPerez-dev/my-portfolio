{
  "slug": "certgames",
  "language": "en",
  "title": "CertGames",
  "subtitle": "Full stack gamified learning SaaS with custom middleware composition, real-time multiplayer, and production CI/CD",
  "description": "A production SaaS platform for gamified cybersecurity certification preparation, featuring 15,000+ practice questions across 14 certifications, real-time multiplayer challenges, and a comprehensive gamification system with 120+ levels, achievements, and streaks.",
  "technical_details": "# Solo-Built Production SaaS\n\nCertGames represents over 3,000 hours of solo development, scaling from a side project into a production monolith serving 1,000+ users with real monthly recurring revenue. The platform hosts 15,000+ practice questions across 14 cybersecurity certifications, a gamification engine with 120 levels, achievements, daily streaks, and a virtual economy. This writeup focuses on the architecture and engineering decisions rather than features.\n\n## Why Flask Over FastAPI?\n\nThe honest answer: Flask made more sense when this started as a small project that didn't warrant FastAPI's overhead. When it grew into a monolith, refactoring would have meant rebuilding everything. Instead, I built my own FastAPI equivalent within Flask. Custom decorators replicate FastAPI's dependency injection patterns, Pydantic handles all request/response validation, gevent provides async patching for concurrent I/O, and the decorator composition system offers the same declarative route configuration. At this point, the framework capabilities match FastAPI while maintaining Flask's ecosystem compatibility.\n\n## Monorepo Architecture\n\nThe codebase spans three frontends and a single Flask application that houses two architecturally distinct systems. The user facing app (`frontend/user-app`) and admin dashboard (`frontend/admin-app`) are separate React TypeScript applications, both served through Nginx with path based routing. An iOS app (`frontend/ios-app`) built with React Native and Expo/EAS shares the same API. While the backend runs as one Flask instance, the admin and user sides maintain separate route structures, decorator patterns, and domain organizations - the admin system alone rivals most standalone applications in scope.\n\nThe admin API alone demonstrates the scale: 20+ domains following a clean DDD structure where each domain contains `routes.py`, `services.py`, `queries.py`, `schemas.py`, `controllers.py`, and `nsdocs.py` for Swagger documentation. Each domain also includes `metadata/` directories documenting nuances, data flows, and integration points with other domains. The `admin/models/` directory houses models across categories like users, content, analytics, and moderation. This separation keeps the admin logic isolated while sharing core infrastructure.\n\n## Decorator Composition System\n\nThe API layer uses a custom decorator stack that composes middleware declaratively. A typical route looks like:\n\n```python\n@content_ns.route(\"/daily/question/answer\")\nclass DailyQuestionAnswerAPI(Resource):\n    @content_ns.doc(**SUBMIT_DAILY_ANSWER_DOC)\n    @current_app.limiter.limit(\"150/minute, 5000/hour\")\n    @SecOps(\n        RL(\"50/M\"),\n        PG(LVL=\"M\", CX=\"AU\"),\n        RS(MX=\"500KB\", MXP=15),\n        TracingGuard(\"detailed\")\n    )\n    @api_endpoint(\n        auth=True,\n        subscription=True,\n        audit=False,\n        json_body=True\n    )\n    @S(SubmitDailyAnswerRequest)\n    @G(load_daily_question)\n    @R(check_not_already_answered)\n    @CertGamesAPI(SubmitDailyAnswerResponse)\n    def post(self):\n        \"\"\"\n        Submit answer to daily question (premium)\n        \"\"\"\n        return submit_daily_question_answer(), 200\n```\n\nEach decorator handles a specific concern: `@api_endpoint` manages auth verification, subscription checks, audit logging, and request body parsing. `@S` (Schema) validates the request body against a Pydantic model. `@G` (Getter) loads required data and injects it into Flask's `g` object. `@R` (Requirement) enforces business rules as guards. `@CertGamesAPI` wraps the response in a consistent envelope with Pydantic validation. This composition lets routes declare their requirements without boilerplate.\n\n## Authentication Architecture\n\nThe auth system implements a three layer fallback chain for maximum compatibility. Primary authentication uses JWT tokens validated through Flask-JWT-Extended. If JWT validation fails or no token exists, the system falls back to session based auth checking `session.get('userId')`. As a final escape hatch for edge cases like WebSocket connections from certain clients, the system accepts an `X-User-Id` header. Each fallback logs the auth method used for debugging.\n\nThree OAuth providers offer passwordless signup: GitHub, Google, and Apple Sign-In. Each provider flow handles token exchange, profile data extraction, and account linking for existing users.\n\nAdmin authentication syncs with the main user system. When an admin logs in, the system validates against the User collection, verifies admin privileges, then creates a mirrored session in the admin context. This unified approach means admins use the same credentials across both applications while maintaining separate session stores and audit trails.\n\n## Quad-Layer Rate Limiting\n\nRate limiting operates across four layers without measurable performance impact. The first layer is a custom Redis backed `SecureRateLimiter` that fingerprints clients using a combination of IP, user agent hash, and authenticated user ID. It implements penalty periods for repeat offenders and tracks patterns across requests. The second layer uses Flask-Limiter for declarative per route limits. The third layer is a global fallback limiter catching anything that slips through route specific rules. The fourth layer is Nginx rate limiting at the reverse proxy level, providing the last line of defense before requests even reach the application.\n\n## Social Platform Features\n\nBeyond certification prep, CertGames functions as a social platform. Users have public profiles with customizable avatars and name colors purchased through the virtual economy. The friend system supports sending/accepting requests, viewing online status, and challenging friends to head to head quizzes on any certification. A real-time messaging system allows direct communication between friends. Public leaderboards rank users by XP, level, and certification specific performance. These social features drive engagement and retention beyond pure study functionality.\n\n## Gamification Engine\n\nThe core study experience spans 14 cybersecurity certifications, each with 10 difficulty tiers ranging from \"very easy\" to \"nuclear\" with 100 questions per tier. Two modes exist: practice mode provides immediate feedback after each question, while exam mode mimics real certification exams with timed sessions and results only shown at completion. Correct answers award 5 coins and 10 XP, with purchasable XP boosts multiplying gains.\n\nThe virtual economy centers on a shop offering avatars, name colors, XP boosts, and streak freezes. Users earn coins through daily activity, achievements, and a daily Performance-Based Question that awards 250 coins for solving a hands on scenario. Role titles progress through tiers like \"APT-29 II,\" \"Admiral IV,\" and ultimately \"Unit 8200\" at max level, displayed on profiles and leaderboards. Certain name colors unlock automatically at milestone levels while others require purchase.\n\nStreaks track consecutive days of activity with milestone rewards throughout - 7 days, 30 days, 90 days, 365 days, and more. Streak freezes purchased from the shop protect against losing progress. Fifty achievements cover everything from answering questions to social interactions to completing challenges. Four interactive games provide variety beyond standard quizzing. A daily newsletter delivers study tips, career advice, cybersecurity news, and pentesting tool breakdowns, though users have to find the signup through an easter egg.\n\n## Monetization and Payments\n\nThe platform operates on a freemium model at $9.99/month. Free users access limited daily practice questions while subscribers unlock unlimited access to 15,000+ questions across 14 certifications, all difficulty tiers, 11 learning tools, daily PBQs, games, and premium features. Web payments process through Stripe with subscription management, payment method updates, and cancellation handling. iOS payments use Apple's In-App Purchase system with custom StoreKit integration and server side receipt validation rather than third party solutions like RevenueCat.\n\nA referral system rewards users 50% of each referred subscription - continuously, not just the first month. The referral tracking, reward distribution, and payout infrastructure live in a separate PostgreSQL backed service I published as a PyPI package. Payouts support multiple methods including PayPal, Venmo, Cash App, Zelle, direct bank transfer, and Stripe Connect for users who prefer instant payouts. Webhook handlers from both Stripe and Apple manage subscription state changes, renewals, cancellations, and payment failures.\n\n## Real-Time WebSocket Architecture\n\nThe WebSocket layer uses Flask-SocketIO with a room based architecture. Each authenticated user automatically joins their personal room (`user_{id}`) on connection. The `SocketManager` singleton provides a clean API for emitting events:\n\n```python\nclass SocketManager:\n    @staticmethod\n    def emit_to_user(user_id: str, event: str, data: Mapping[str, Any]) -> bool:\n        socketio = SocketManager._get_socketio()\n        if not socketio:\n            return False\n        room = SocketManager.get_user_room(user_id)\n        socketio.emit(event, data, room=room)\n        return True\n\n    @staticmethod\n    def emit_to_users(user_ids: list[str], event: str, data: Mapping[str, Any]) -> int:\n        success_count = 0\n        for user_id in user_ids:\n            if SocketManager.emit_to_user(user_id, event, data):\n                success_count += 1\n        return success_count\n```\n\nPresence tracking notifies friends when users come online/offline. Challenge events push real-time updates as opponents submit answers. Support threads enable live chat between users and admins with typing indicators. The frontend implements corresponding hooks for type-safe event handling with automatic reconnection logic.\n\n## Caching Strategy\n\nRedis handles multiple caching patterns. User data caches with pickle/base64 serialization for complex Python objects, using a `user_cache:{id}` key pattern with TTL based expiration. Leaderboard caching stores previous state alongside current rankings, enabling efficient diff calculations for live updates. Cache invalidation triggers on relevant mutations: XP gains invalidate user cache and potentially leaderboard positions, purchases invalidate inventory, and so on. The caching layer reduces MongoDB load significantly on high traffic endpoints like leaderboards and user profiles.\n\n## Testing Infrastructure\n\nThe test suite includes 3,000+ pytest tests achieving 85% code coverage. Tests span unit tests for business logic, integration tests for API endpoints, and specific tests for edge cases in the gamification engine. Fixtures provide isolated test databases and authenticated test clients. The CI pipeline runs the full suite on every PR, blocking merges on any failure.\n\n## Code Quality and Linting\n\nEvery commit passes through an aggressive linting gauntlet: Ruff for fast Python linting, Pylint for deeper static analysis, MyPy for strict type checking, Bandit for security scanning, ESLint for TypeScript/React, Stylelint for SCSS, and `tsc --noEmit` for frontend type verification. Code formatting uses YAPF rather than Black. YAPF offers significantly more configuration granularity for formatting preferences, though it requires more setup. The tradeoff is worth it for consistent, opinionated styling across the codebase.\n\n## CI/CD Pipeline\n\nThe deployment flow is fully automated. Pushing to any branch triggers GitHub Actions to create a PR automatically. The PR runs parallel lint jobs using a matrix strategy across all linters, then executes the full test suite. On all checks passing, the PR auto merges to the prod branch. A self hosted runner on the production server detects the merge and triggers `deploy.yml`, which rebuilds only changed containers and performs a rolling restart. Slack webhooks notify at every stage: PR created, checks started, checks passed/failed, merge complete, deployment started, deployment succeeded. The entire flow from push to production takes under 25 minutes with zero manual intervention.\n\n## Infrastructure and DevOps\n\nProduction runs on Docker Compose with services including the Flask app under uWSGI, Nginx as reverse proxy, Redis with security hardening, Celery workers for background tasks, MongoDB, MinIO for object storage, and Ollama for local LLM inference. uWSGI was chosen over Gunicorn deliberately. For simpler applications, Gunicorn's ease of use wins. But at this scale, uWSGI's granular configuration options for worker management, request routing, and resource limits provide control that Gunicorn can't match.\n\nCloudflare Tunnels handle ingress without exposing ports. Uptime Kuma monitors all services with Slack alerting. Portainer provides container management UI. Autoheal automatically restarts unhealthy containers. The setup handles traffic spikes gracefully while keeping infrastructure costs minimal on a single server.\n\nThe stack also includes PostgreSQL, used specifically for a custom Stripe referral system I published as a PyPI package. The package implements referral tracking with configurable reward structures, using PostgreSQL adapters for persistence. This means the production environment runs both MongoDB (primary datastore) and PostgreSQL (referral subsystem), though they serve distinct purposes.\n\n## Frontend Architecture\n\nBoth React applications use TypeScript in strict mode with no `any` escapes. TanStack Query handles all server state with proper cache invalidation, optimistic updates, and error boundaries. Zustand manages UI state and auth tokens with persistence. SCSS modules provide scoped styling without CSS-in-JS runtime overhead.\n\nType safety extends to API responses through runtime validation:\n\n```typescript\nexport const useSendChallenge = (): UseMutationResult<\n  SendChallengeResponse,\n  AxiosError,\n  SendChallengeRequest\n> => {\n  const queryClient = useQueryClient();\n  return useMutation<SendChallengeResponse, AxiosError, SendChallengeRequest>({\n    meta: { skipGlobalErrorHandler: true },\n    mutationFn: async (data: SendChallengeRequest): Promise<SendChallengeResponse> => {\n      const response = await socialMutations.sendChallenge(data);\n      if (!isValidSendChallengeResponse(response)) {\n        throw new Error(SOCIAL_ERROR_MESSAGES.INVALID_SEND_CHALLENGE_RESPONSE);\n      }\n      return response;\n    },\n    onSuccess: (): void => {\n      toast.success('Challenge sent successfully!');\n    },\n    onSettled: async (): Promise<void> => {\n      await queryClient.invalidateQueries({\n        queryKey: socialQueryKeys.challengesList(),\n        refetchType: 'active',\n      });\n    },\n    onError: createApiErrorHandler(SOCIAL_ERROR_CONTEXTS.SEND_CHALLENGE),\n  });\n};\n```\n\nType guards like `isValidSendChallengeResponse` validate API responses at runtime, catching backend contract violations before they propagate through the UI. Custom error handlers provide consistent user facing error messages while logging details for debugging.\n\n## Frontend WebSocket Integration\n\nThe socket layer mirrors backend patterns with a singleton client and typed hooks:\n\n```typescript\nexport function useSocketEvent<K extends keyof SocketEventMap>(\n  event: K,\n  handler: SocketEventMap[K],\n  deps: React.DependencyList = [],\n): void {\n  const savedHandler = useRef<SocketEventMap[K]>(handler);\n  \n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    const eventHandler = ((...args: unknown[]): void => {\n      (savedHandler.current as (...args: unknown[]) => void)(...args);\n    }) as SocketEventMap[K];\n\n    socketClient.on(event, eventHandler);\n    return (): void => {\n      socketClient.off(event, eventHandler);\n    };\n  }, [event, ...deps]);\n}\n```\n\nDomain specific listeners like `useSocialSocketListeners` handle friend requests, challenge updates, presence changes, and direct messages. Each event type invalidates relevant TanStack Query caches, keeping UI state synchronized without polling. The socket client manages reconnection with exponential backoff and re-authenticates automatically on reconnect.\n\n## Learning Tools\n\nThe platform includes 11 interactive learning tools beyond standard practice tests. These run on self hosted Ollama for local inference rather than external API calls, keeping costs predictable and response times fast. The tools range from flashcard generators to scenario based simulations, all integrated with the XP and achievement systems.\n",
  "tech_stack": [
    "Python",
    "Flask",
    "Flask-RESTX",
    "Pydantic",
    "MongoDB",
    "MongoEngine",
    "Redis",
    "Celery",
    "PostgreSQL",
    "WebSockets",
    "uWSGI",
    "React",
    "TypeScript",
    "TanStack Query",
    "Zustand",
    "SCSS",
    "React Native",
    "Expo",
    "Docker",
    "Nginx",
    "GitHub Actions",
    "Cloudflare Tunnels"
  ],
  "code_snippet": "class GetUserResponse(BaseModel):\n    \"\"\"Response schema for GET /account/user\"\"\"\n    id: str = Field(..., alias=\"_id\", description=\"User ID\")\n    username: str = Field(..., description=\"Username\")\n    email: str = Field(..., description=\"Email address\")\n    coins: float = Field(..., description=\"Coin balance\")\n    xp: float = Field(..., description=\"XP points\")\n    level: int = Field(..., description=\"Current level\")\n    achievements: list[str] = Field(..., description=\"Achievement IDs\")\n    achievement_counters: dict[str, Any] | None = Field(..., description=\"Achievement counters\")\n    currentAvatar: str | None = Field(..., description=\"Equipped avatar ID\")\n    nameColor: str | None = Field(..., description=\"Name color\")\n    xpBoost: float = Field(..., description=\"XP boost multiplier\")\n    purchasedItems: list[str] = Field(..., description=\"Purchased item IDs\")\n    subscriptionActive: bool = Field(..., description=\"Subscription active\")\n    subscriptionType: str = Field(..., description=\"Subscription type\")\n    subscriptionPlan: str = Field(..., description=\"Subscription plan\")\n    subscriptionStatus: str | None = Field(..., description=\"Subscription status\")\n    subscriptionPlatform: str | None = Field(..., description=\"Platform (stripe/apple)\")\n    current_streak: int = Field(..., description=\"Current daily streak\")\n    longest_streak: int = Field(..., description=\"Longest streak ever\")\n    streak_freeze_count: int = Field(..., description=\"Freezes used this month\")\n    streak_milestones_claimed: list[int] = Field(..., description=\"Claimed milestones\")\n    current_role: str = Field(..., description=\"Role name based on level\")\n    next_role: dict[str, str | int] | None = Field(..., description=\"Next role info\")\n    referralCodeUsed: str | None = Field(..., description=\"Referral code used\")\n    referredBy: str | None = Field(..., description=\"Referrer user ID\")\n    stripeCustomerId: str | None = Field(..., description=\"Stripe customer ID\")\n    stripeSubscriptionId: str | None = Field(..., description=\"Stripe subscription ID\")\n    appleTransactionId: str | None = Field(..., description=\"Apple transaction ID\")\n    stripeConnectAccountId: str | None = Field(..., description=\"Stripe Connect ID\")\n    stripeConnectOnboarded: bool = Field(..., description=\"Connect onboarding done\")\n    stripeConnectPayoutsEnabled: bool = Field(..., description=\"Payouts enabled\")\n    # ... 40+ additional fields for auth, tracking, payments, social",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/CertGames-Core/blob/prod/backend/api/domains/account/schemas/responses.py",
  "github_url": "https://github.com/CarterPerez-dev/CertGames-Core",
  "website_url": "https://certgames.com",
  "demo_url": null,
  "docs_url": "https://certgames.com/api/docs/",
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": "https://apps.apple.com/us/app/comptia-certgames-exam-prep/id6743811522",
  "android_url": null,
  "forks_count": null,
  "display_order": 0,
  "is_complete": true,
  "status": "active",
  "start_date": "2025-10-01",
  "end_date": null,
  "is_featured": true,
  "stars_count": 7,
  "users_count": 1000,
  "downloads_count": 400,
  "banner_url": "project-certgames/banner.webp",
  "thumbnail_url": "project-certgames/thumbnail.webp",
  "screenshots": [
    "project-certgames/screenshot1.webp",
    "project-certgames/screenshot2.webp",
    "project-certgames/screenshot3.webp"
  ]
}
