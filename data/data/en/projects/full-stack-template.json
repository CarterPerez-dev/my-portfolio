{
  "slug": "fullstack-template",
  "language": "en",
  "title": "Full Stack Template",
  "subtitle": "Built for me to copy from. Skips straight to the interesting problems.",
  "description": "Personal boilerplate for FastAPI + React applications. JWT auth with token rotation, async PostgreSQL, type safety on both ends, Docker setup, and Nginx config. Everything I got tired of rebuilding from scratch.",
  "technical_details": "Personal boilerplate I built to stop solving the same problems. Every project needs auth, database migrations, Docker config, and type safety. This does those once so I can skip to the actual interesting work.\n\n## SafeEnum: Storing Values, Not Names\n\nSQLAlchemy has a footgun most people don't know about until it bites them. By default, it stores enum NAMES in the database, not values. Rename `Color.RED` to `Color.LEGACY_RED` and suddenly your entire table is unreadable because the database still has `RED` stored and SQLAlchemy can't map it back.\n\nThe fix is `values_callable` to store actual values, plus an `unknown_value` fallback so new code can read old data (or vice versa) without exploding:\n\n```python\nclass SafeEnum(sa.Enum):\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = lambda e: [str(i.value) for i in e]\n        super().__init__(*enums, **kw)\n        self._unknown_value = kw.get(\"unknown_value\")\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise\n```\n\nNow enum member renames are safe refactors, not database migrations.\n\n## Timing-Safe Password Verification\n\nLogin endpoints leak information through response time. If you return early when a user doesn't exist, attackers can enumerate valid emails by measuring how long requests take. The fix is to always do the same amount of work:\n\n```python\nDUMMY_HASH = password_hasher.hash(\"dummy_password_for_timing_attack_prevention\")\n\nasync def verify_password_with_timing_safety(\n    plain_password: str,\n    hashed_password: str | None,\n) -> tuple[bool, str | None]:\n    if hashed_password is None:\n        # User doesn't exist, but still do argon2 work\n        await asyncio.to_thread(password_hasher.verify, plain_password, DUMMY_HASH)\n        return False, None\n    return await verify_password(plain_password, hashed_password)\n```\n\nWhether the email exists or not, the response takes the same time. Also handles automatic rehashing when argon2 params get upgraded.\n\n## Token Family Tracking\n\nRefresh tokens get stolen. The question is what happens when they do. Most implementations just check if the token is valid. This one tracks token families:\n\n```python\nif stored_token.is_revoked:\n    # Revoked token was reused. This is a replay attack.\n    # Nuke the entire family.\n    await RefreshTokenRepository.revoke_family(\n        self.session,\n        stored_token.family_id\n    )\n    raise TokenRevokedError()\n\n# Normal rotation: revoke current, issue new with same family_id\nawait RefreshTokenRepository.revoke_token(self.session, stored_token)\nnew_token = create_refresh_token(user.id, stored_token.family_id)\n```\n\nWhen you refresh, the old token is revoked and a new one is issued with the same `family_id`. If someone tries to use a revoked token (attacker replaying a stolen token), the entire family gets nuked. Legitimate user gets logged out, attacker gets nothing.\n\n## Frontend Request Queuing\n\nMultiple API calls can hit 401 at the same time. Without coordination, each one tries to refresh the token independently, causing race conditions and wasted requests. The interceptor queues everything behind a single refresh:\n\n```typescript\nif (isRefreshing) {\n  // Another request is already refreshing. Queue this one.\n  return new Promise((resolve, reject) => {\n    addRefreshSubscriber(\n      (newToken) => {\n        originalRequest.headers.Authorization = `Bearer ${newToken}`\n        resolve(apiClient(originalRequest))\n      },\n      (error) => reject(error)\n    )\n  })\n}\n\n// First request to fail becomes the refresher\nisRefreshing = true\nconst newToken = await handleTokenRefresh()\nprocessRefreshQueue(null, newToken)  // Unblock all queued requests\n```\n\nOne refresh, all pending requests get the new token and retry automatically.\n\n## Zod as API Contract\n\nTypeScript types disappear at runtime. The backend could return garbage and `as UserResponse` would happily accept it. Zod schemas validate at runtime and infer the types:\n\n```typescript\nexport const isValidUserResponse = (data: unknown): data is UserResponse => {\n  const result = userResponseSchema.safeParse(data)\n  return result.success\n}\n\n// Usage\nconst data: unknown = response.data\nif (!isValidUserResponse(data)) {\n  throw new UserResponseError('Invalid response', endpoint)\n}\n// data is now typed as UserResponse\n```\n\nFrontend doesn't trust backend. Every API response gets validated before use.\n\n## Rust Toolchain\n\nThe dev tooling runs on Rust. Not for ideological reasons, just because it's measurably faster:\n\n- **uv** replaces pip and venv. `uv sync` creates `.venv` and installs dependencies in under a second.\n- **ruff** replaces pylint and flake8. Linting happens in milliseconds.\n- **ty** is Astral's mypy replacement (December 2025, pre-1.0 but usable). Same speed story.\n- **pnpm**: Replaces npm. Uses **content addressable storage** to link dependencies from a single global store, saving gigabytes of disk space and making installs near instant.\n- **biome** replaces eslint and prettier. Formatting and linting in one pass, instantly.\n\nYou won't wait more than a second for any linting or package management operation.\n\n## Everything Else\n\nAsync SQLAlchemy 2.0 with a dual engine setup (async for runtime, sync for Alembic migrations from the same connection string). Argon2id for password hashing. Docker Compose with optimized layer caching. Nginx with WebSocket upgrade handling and timed logging for latency debugging. SCSS design tokens. Zustand stores with persistence. No magic strings or numbers anywhere in the codebase.",
  "tech_stack": [
    "FastAPI",
    "SQLAlchemy",
    "PostgreSQL",
    "React",
    "TypeScript",
    "Zod",
    "Docker",
    "Nginx",
    "uv",
    "ruff",
    "pnpm",
    "biome"
  ],
  "github_url": "https://github.com/CarterPerez-dev/fullstack-template",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "def enum_values_callable(enum_class: type[Enum]) -> list[str]:\n    \"\"\"\n    Returns enum VALUES (not names) for SQLAlchemy storage\n\n    Prevents the common trap where SQLAlchemy stores enum NAMES by default,\n    causing database breakage if you rename an enum member\n    \"\"\"\n    return [str(item.value) for item in enum_class]\n\n\nclass SafeEnum(sa.Enum):\n    \"\"\"\n    SQLAlchemy Enum type that stores VALUES and handles unknown values gracefully\n    \"\"\"\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = enum_values_callable\n        super().__init__(*enums, **kw)\n        self._unknown_value = (\n            kw[\"_adapted_from\"]._unknown_value\n            if \"_adapted_from\" in kw else kw.get(\"unknown_value\")\n        )\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/fullstack-template/blob/main/backend/app/core/enums.py",
  "thumbnail_url": "project-full-stack-template/thumbnail.webp",
  "banner_url": "project-full-stack-template/banner.webp",
  "screenshots": null,
  "stars_count": 42,
  "forks_count": 2,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": true,
  "status": "active",
  "start_date": "2025-12-11",
  "end_date": null
}
