{
  "slug": "kill-pr0cess-inc",
  "language": "en",
  "title": "kill-pr0cess.inc",
  "subtitle": "A meta performance showcase: Rust backend + SolidJS frontend measuring their own speed",
  "technical_details": "The premise is deliberately circular. Take the two fastest frameworks in their respective domains, Rust with Axum on the backend and SolidJS on the frontend, then build something whose entire purpose is displaying how fast it runs. It's a website about itself. The dark aesthetic isn't decorative; it strips away everything except the data, the metrics, the raw output of computation observing computation. Somewhere between a benchmark suite and an art project, though calling it either feels like missing the point.\n\n```rust\n#[derive(Clone)]\npub struct AppState {\n    pub db_pool: DatabasePool,\n    pub redis_client: redis::Client,\n    pub github_service: GitHubService,\n    pub fractal_service: FractalService,\n    pub performance_service: PerformanceService,\n    pub cache_service: CacheService,\n    pub config: Config,\n    pub metrics: MetricsCollector,\n}\n```\n\nThe backend architecture follows standard dependency injection patterns. AppState holds every service the application needs: database pool, Redis client, GitHub integration, performance monitoring, caching. Services get initialized once at startup and passed through Axum's state extraction. The fractal service exists purely to give the CPU something intensive to compute, parallelized across cores with Rayon. Everything else supports the core loop of collecting metrics about the system running the code that collects the metrics.\n\n```rust\nlet system_perf = SystemPerformance {\n    cpu_usage_percent: system.global_cpu_info().cpu_usage() as f64,\n    memory_usage_percent: ((total - available) / total) * 100.0,\n    load_average_1m: system.load_average().one,\n    load_average_5m: system.load_average().five,\n    uptime_seconds: system.uptime(),\n    active_processes: system.processes().len() as u32,\n};\n```\n\nHealth checks go deeper than returning 200 OK. The endpoint tests database connectivity, pings Redis, validates GitHub API rate limits, and runs a small fractal computation to verify the engine works. Each service returns healthy, degraded, or unhealthy status with response times. If GitHub's rate limit drops below 10%, the system marks itself degraded before anything actually breaks. The performance routes expose CPU, memory, disk, network stats, plus application-level metrics like cache hit rates and connection pool sizes. Real telemetry, not mock data.\n\n```typescript\nconst filteredRepositories = createMemo(() => {\n  return state.repositories.filter(repo => {\n    if (state.filters.search) {\n      const searchTerm = state.filters.search.toLowerCase();\n      const searchableText = `${repo.name} ${repo.description || ''}`;\n      if (!searchableText.includes(searchTerm)) return false;\n    }\n    if (state.filters.language && repo.language !== state.filters.language) {\n      return false;\n    }\n    return true;\n  });\n});\n```\n\nSolidJS was chosen specifically because it doesn't use a virtual DOM. Updates are surgical, targeting exactly the DOM nodes that changed. The hooks like useGitHub and usePerformance wrap reactive stores with createStore and derive computed values with createMemo. When metrics update, only the numbers re-render, not the entire dashboard. Combined with Rust's near-zero latency API responses, the result is a UI that feels like it's rendering before you asked. Which, given what this project is about, seems appropriate.",
  "description": "one and nun are the only true form of nuetrality because two things are not allowed to exist | lux-t",
  "tech_stack": ["Rust", "Axum", "Tokio", "SQLx", "PostgreSQL", "Redis", "SolidJS", "TypeScript", "Tailwind CSS", "Rayon", "Docker"],
  "github_url": "https://github.com/CarterPerez-dev/kill-pr0cess.inc",
  "demo_url": "https://dihydroxy.nz",
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "thumbnail_url": null,
  "banner_url": null,
  "screenshots": null,
  "code_snippet": "impl AppState {\n    pub async fn health_check(&self) -> Result<serde_json::Value> {\n        let db_status = match sqlx::query(\"SELECT 1 as test\")\n            .fetch_one(&self.db_pool)\n            .await\n        {\n            Ok(_) => \"healthy\",\n            Err(_) => \"unhealthy\",\n        };\n\n        let mut conn = self.redis_client.get_async_connection().await?;\n        let redis_status = match redis::cmd(\"PING\")\n            .query_async::<_, String>(&mut conn)\n            .await\n        {\n            Ok(_) => \"healthy\",\n            Err(_) => \"unhealthy\",\n        };\n\n        let system_info = self.performance_service.get_system_info().await?;\n\n        Ok(serde_json::json!({\n            \"status\": if db_status == \"healthy\" && redis_status == \"healthy\" { \"healthy\" } else { \"unhealthy\" },\n            \"timestamp\": chrono::Utc::now(),\n            \"services\": {\n                \"database\": db_status,\n                \"redis\": redis_status,\n                \"github_api\": \"healthy\",\n                \"fractal_engine\": \"healthy\"\n            },\n            \"system\": {\n                \"cpu_usage\": system_info[\"cpu_usage_percent\"],\n                \"memory_usage\": system_info[\"memory_usage_percent\"],\n                \"uptime_seconds\": system_info[\"uptime_seconds\"]\n            }\n        }))\n    }\n}",
  "code_language": "rust",
  "code_filename": "backend/src/lib.rs",
  "stars_count": null,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "display_order": 50,
  "is_complete": true,
  "is_featured": false,
  "status": "active",
  "start_date": "2025-06-01",
  "end_date": null
}
