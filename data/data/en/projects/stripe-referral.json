{
  "slug": "stripe-referral",
  "language": "en",
  "title": "stripe-referral",
  "subtitle": "Framework-agnostic referral package with pluggable payout adapters",
  "description": "Built this for CertGames when I needed referral tracking with actual payout automation. Couldn't find an existing package that handled the full lifecycle without being tied to Django or some specific payment provider, so I extracted what I built into a standalone PyPI package. SQLAlchemy based, works with any Python web framework, ships with adapters for Stripe Connect, Wise, and manual bank transfers.",
  "technical_details": "The adapter pattern is the core abstraction here. Every payout provider implements `PayoutAdapter` with just two methods: `send_payout` and `validate_recipient`. Adding Wise support meant writing one class that hits their API, no changes to the service layer. The adapters return TypedDict results instead of raising exceptions for expected failures, so you get `PayoutResult(success=False, error=\"...\")` rather than try/catch everywhere.\n\n```python\n# Stripe Connect adapter validates the account exists and can receive funds\naccount = stripe.Account.retrieve(account_id)\nif not account.payouts_enabled:\n    return RecipientValidation(valid=False, error=\"Payouts not enabled\")\n```\n\nThe repository layer keeps SQLAlchemy queries isolated from business logic. Each model gets its own repository with typed methods. `ReferralTrackingRepository.get_user_earnings()` returns a dict with total, pending, and paid amounts calculated via SQLAlchemy's `case()` expressions. The service layer calls repositories and never touches the ORM directly, which made unit testing way easier since I can mock at the repository boundary.\n\n```python\n# Service layer stays clean, repositories handle the query complexity\nearnings = tracking_repo.get_user_earnings(user_id)\nreturn UserEarnings(total=earnings[\"total\"], pending=earnings[\"pending\"], paid=earnings[\"paid\"])\n```\n\nReferral code generation uses a combination of `secrets.token_urlsafe` and SHA256 hashing to produce codes like `REF_A3F2B1_xK9mNp`. The generator takes a collision check callback so it retries automatically if a code already exists. Ten attempts max before raising `CodeGenerationError`. This pattern keeps the generation logic testable without needing a real database in unit tests.\n\n```python\ndef generate_unique_code(user_id: str, program_key: str, check_collision_fn) -> str:\n    for _ in range(CODE_GENERATION_RETRY_ATTEMPTS):\n        code = _generate_code_string(user_id, program_key)\n        if not check_collision_fn(code):\n            return code\n    raise CodeGenerationError(\"Failed after max attempts\")\n```\n\nThe exception hierarchy is pretty granular. There's a base `StripeReferralError` that everything inherits from, then specific errors for each failure mode: `CodeExpiredError`, `CodeMaxUsesReachedError`, `SelfReferralError`, `PayoutAlreadyExistsError`, and about a dozen others. Each exception accepts arbitrary context kwargs that get formatted into the string representation. Makes debugging easier when you can see `CodeExpiredError: Code 'REF_ABC' expired at 2025-01-15 (code=REF_ABC, expires_at=2025-01-15)`.\n\nPydantic handles all input validation on the schema layer. Request models strip whitespace and enforce length limits before data hits the service layer. The `CreateProgramRequest` schema validates currency codes are exactly 3 characters and uppercases them automatically. Services receive already validated data and return TypedDict results, keeping the API boundaries clean. Alembic migrations ship with the package so users can run `alembic upgrade head` to set up tables in their existing database.",
  "tech_stack": [
    "Python",
    "SQLAlchemy",
    "Stripe Connect",
    "Pydantic",
    "Alembic",
    "PostgreSQL"
  ],
  "github_url": "https://github.com/CarterPerez-dev/stripe-referral",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": "https://pypi.org/project/stripe-referral/",
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "class PayoutAdapter(ABC):\n    @abstractmethod\n    def send_payout(\n        self,\n        user_id: str,\n        amount: float,\n        currency: str,\n        recipient_data: dict[str, Any],\n    ) -> PayoutResult:\n        \"\"\"Process a payout to the user\"\"\"\n\n    @abstractmethod\n    def validate_recipient(\n        self,\n        recipient_data: dict[str, Any]\n    ) -> RecipientValidation:\n        \"\"\"Validate recipient data before attempting payout\"\"\"",
  "code_language": "python",
  "code_filename": "src/stripe_referral/adapters/base.py",
  "banner_url": null,
  "thumbnail_url": null, 
  "screenshots": null,
  "stars_count": 3,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": false,
  "status": "active",
  "start_date": "2025-11-20",
  "end_date": null
}
