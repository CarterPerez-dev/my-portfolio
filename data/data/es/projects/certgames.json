{
  "slug": "certgames",
  "language": "es",
  "title": "CertGames",
  "subtitle": "SaaS full stack de aprendizaje gamificado con composición de middleware personalizado, multijugador en tiempo real y CI/CD en producción",
  "description": "Una plataforma SaaS en producción para la preparación gamificada de certificaciones de ciberseguridad, con más de 15,000 preguntas de práctica en 14 certificaciones, desafíos multijugador en tiempo real y un sistema integral de gamificación con más de 120 niveles, logros y rachas.",
  "technical_details": "# SaaS en Producción Desarrollado en Solitario\n\nCertGames representa más de 3,000 horas de desarrollo en solitario, escalando desde un proyecto secundario hasta un monolito en producción que sirve a más de 1,000 usuarios con ingresos recurrentes mensuales reales. La plataforma aloja más de 15,000 preguntas de práctica en 14 certificaciones de ciberseguridad, un motor de gamificación con 120 niveles, logros, rachas diarias y una economía virtual. Este documento se centra en la arquitectura y las decisiones de ingeniería en lugar de las características.\n\n## ¿Por Qué Flask en Lugar de FastAPI?\n\nLa respuesta honesta: Flask tenía más sentido cuando esto comenzó como un proyecto pequeño que no justificaba la sobrecarga de FastAPI. Cuando creció hasta convertirse en un monolito, refactorizar habría significado reconstruir todo. En su lugar, construí mi propio equivalente de FastAPI dentro de Flask. Los decoradores personalizados replican los patrones de inyección de dependencias de FastAPI, Pydantic maneja toda la validación de request/response, gevent proporciona patching asíncrono para I/O concurrente, y el sistema de composición de decoradores ofrece la misma configuración declarativa de rutas. En este punto, las capacidades del framework igualan a FastAPI mientras mantienen la compatibilidad con el ecosistema de Flask.\n\n## Arquitectura Monorepo\n\nEl código abarca tres frontends y una única aplicación Flask que aloja dos sistemas arquitectónicamente distintos. La aplicación de usuario (`frontend/user-app`) y el panel de administración (`frontend/admin-app`) son aplicaciones React TypeScript separadas, ambas servidas a través de Nginx con enrutamiento basado en rutas. Una aplicación iOS (`frontend/ios-app`) construida con React Native y Expo/EAS comparte la misma API. Aunque el backend se ejecuta como una instancia Flask, los lados de admin y usuario mantienen estructuras de rutas separadas, patrones de decoradores y organizaciones de dominio - el sistema de admin por sí solo rivaliza con la mayoría de las aplicaciones independientes en alcance.\n\nSolo la API de admin demuestra la escala: más de 20 dominios siguiendo una estructura DDD limpia donde cada dominio contiene `routes.py`, `services.py`, `queries.py`, `schemas.py`, `controllers.py` y `nsdocs.py` para documentación Swagger. Cada dominio también incluye directorios `metadata/` que documentan matices, flujos de datos y puntos de integración con otros dominios. El directorio `admin/models/` aloja modelos en categorías como usuarios, contenido, analíticas y moderación. Esta separación mantiene la lógica de admin aislada mientras comparte la infraestructura central.\n\n## Sistema de Composición de Decoradores\n\nLa capa API utiliza un stack de decoradores personalizado que compone middleware de forma declarativa. Una ruta típica se ve así:\n\n```python\n@content_ns.route(\"/daily/question/answer\")\nclass DailyQuestionAnswerAPI(Resource):\n    @content_ns.doc(**SUBMIT_DAILY_ANSWER_DOC)\n    @current_app.limiter.limit(\"150/minute, 5000/hour\")\n    @SecOps(\n        RL(\"50/M\"),\n        PG(LVL=\"M\", CX=\"AU\"),\n        RS(MX=\"500KB\", MXP=15),\n        TracingGuard(\"detailed\")\n    )\n    @api_endpoint(\n        auth=True,\n        subscription=True,\n        audit=False,\n        json_body=True\n    )\n    @S(SubmitDailyAnswerRequest)\n    @G(load_daily_question)\n    @R(check_not_already_answered)\n    @CertGamesAPI(SubmitDailyAnswerResponse)\n    def post(self):\n        \"\"\"\n        Submit answer to daily question (premium)\n        \"\"\"\n        return submit_daily_question_answer(), 200\n```\n\nCada decorador maneja una preocupación específica: `@api_endpoint` gestiona la verificación de autenticación, comprobaciones de suscripción, registro de auditoría y análisis del cuerpo de la solicitud. `@S` (Schema) valida el cuerpo de la solicitud contra un modelo Pydantic. `@G` (Getter) carga los datos requeridos y los inyecta en el objeto `g` de Flask. `@R` (Requirement) aplica reglas de negocio como guardas. `@CertGamesAPI` envuelve la respuesta en un envelope consistente con validación Pydantic. Esta composición permite que las rutas declaren sus requisitos sin boilerplate.\n\n## Arquitectura de Autenticación\n\nEl sistema de autenticación implementa una cadena de fallback de tres capas para máxima compatibilidad. La autenticación primaria utiliza tokens JWT validados a través de Flask-JWT-Extended. Si la validación JWT falla o no existe token, el sistema recurre a la autenticación basada en sesión verificando `session.get('userId')`. Como escape final para casos extremos como conexiones WebSocket desde ciertos clientes, el sistema acepta un header `X-User-Id`. Cada fallback registra el método de autenticación utilizado para depuración.\n\nTres proveedores OAuth ofrecen registro sin contraseña: GitHub, Google y Apple Sign-In. Cada flujo de proveedor maneja el intercambio de tokens, extracción de datos de perfil y vinculación de cuentas para usuarios existentes.\n\nLa autenticación de admin se sincroniza con el sistema de usuario principal. Cuando un admin inicia sesión, el sistema valida contra la colección User, verifica privilegios de admin, luego crea una sesión reflejada en el contexto de admin. Este enfoque unificado significa que los admins usan las mismas credenciales en ambas aplicaciones mientras mantienen almacenes de sesión y registros de auditoría separados.\n\n## Rate Limiting de Cuatro Capas\n\nEl rate limiting opera en cuatro capas sin impacto medible en el rendimiento. La primera capa es un `SecureRateLimiter` personalizado respaldado por Redis que identifica clientes usando una combinación de IP, hash de user agent e ID de usuario autenticado. Implementa períodos de penalización para infractores reincidentes y rastrea patrones entre solicitudes. La segunda capa usa Flask-Limiter para límites declarativos por ruta. La tercera capa es un limitador global de respaldo que captura cualquier cosa que pase las reglas específicas de ruta. La cuarta capa es el rate limiting de Nginx a nivel de reverse proxy, proporcionando la última línea de defensa antes de que las solicitudes lleguen a la aplicación.\n\n## Características de Plataforma Social\n\nMás allá de la preparación para certificaciones, CertGames funciona como una plataforma social. Los usuarios tienen perfiles públicos con avatares personalizables y colores de nombre comprados a través de la economía virtual. El sistema de amigos soporta enviar/aceptar solicitudes, ver estado en línea y desafiar amigos a quizzes uno contra uno en cualquier certificación. Un sistema de mensajería en tiempo real permite comunicación directa entre amigos. Los rankings públicos clasifican usuarios por XP, nivel y rendimiento específico por certificación. Estas características sociales impulsan el engagement y la retención más allá de la funcionalidad pura de estudio.\n\n## Motor de Gamificación\n\nLa experiencia de estudio principal abarca 14 certificaciones de ciberseguridad, cada una con 10 niveles de dificultad que van desde \"muy fácil\" hasta \"nuclear\" con 100 preguntas por nivel. Existen dos modos: el modo práctica proporciona feedback inmediato después de cada pregunta, mientras que el modo examen simula exámenes de certificación reales con sesiones cronometradas y resultados mostrados solo al finalizar. Las respuestas correctas otorgan 5 monedas y 10 XP, con multiplicadores de XP comprables.\n\nLa economía virtual se centra en una tienda que ofrece avatares, colores de nombre, multiplicadores de XP y congeladores de racha. Los usuarios ganan monedas a través de actividad diaria, logros y una Pregunta Basada en Rendimiento diaria que otorga 250 monedas por resolver un escenario práctico. Los títulos de rol progresan a través de niveles como \"APT-29 II\", \"Admiral IV\" y finalmente \"Unit 8200\" en el nivel máximo, mostrados en perfiles y rankings. Ciertos colores de nombre se desbloquean automáticamente en niveles hito mientras que otros requieren compra.\n\nLas rachas rastrean días consecutivos de actividad con recompensas en hitos: 7 días, 30 días, 90 días, 365 días y más. Los congeladores de racha comprados en la tienda protegen contra perder el progreso. Cincuenta logros cubren desde responder preguntas hasta interacciones sociales y completar desafíos. Cuatro juegos interactivos proporcionan variedad más allá de los quizzes estándar. Un boletín diario entrega consejos de estudio, consejos de carrera, noticias de ciberseguridad y análisis de herramientas de pentesting, aunque los usuarios tienen que encontrar la suscripción a través de un easter egg.\n\n## Monetización y Pagos\n\nLa plataforma opera con un modelo freemium a $9.99/mes. Los usuarios gratuitos acceden a preguntas de práctica diarias limitadas mientras que los suscriptores desbloquean acceso ilimitado a más de 15,000 preguntas en 14 certificaciones, todos los niveles de dificultad, 11 herramientas de aprendizaje, PBQs diarios, juegos y características premium. Los pagos web se procesan a través de Stripe con gestión de suscripciones, actualización de métodos de pago y manejo de cancelaciones. Los pagos iOS usan el sistema In-App Purchase de Apple con integración StoreKit personalizada y validación de recibos del lado del servidor en lugar de soluciones de terceros como RevenueCat.\n\nUn sistema de referidos recompensa a los usuarios con el 50% de cada suscripción referida - continuamente, no solo el primer mes. El seguimiento de referidos, distribución de recompensas e infraestructura de pagos viven en un servicio separado respaldado por PostgreSQL que publiqué como paquete PyPI. Los pagos soportan múltiples métodos incluyendo PayPal, Venmo, Cash App, Zelle, transferencia bancaria directa y Stripe Connect para usuarios que prefieren pagos instantáneos. Los handlers de webhooks tanto de Stripe como de Apple gestionan cambios de estado de suscripción, renovaciones, cancelaciones y fallos de pago.\n\n## Arquitectura WebSocket en Tiempo Real\n\nLa capa WebSocket usa Flask-SocketIO con una arquitectura basada en rooms. Cada usuario autenticado se une automáticamente a su room personal (`user_{id}`) al conectarse. El singleton `SocketManager` proporciona una API limpia para emitir eventos:\n\n```python\nclass SocketManager:\n    @staticmethod\n    def emit_to_user(user_id: str, event: str, data: Mapping[str, Any]) -> bool:\n        socketio = SocketManager._get_socketio()\n        if not socketio:\n            return False\n        room = SocketManager.get_user_room(user_id)\n        socketio.emit(event, data, room=room)\n        return True\n\n    @staticmethod\n    def emit_to_users(user_ids: list[str], event: str, data: Mapping[str, Any]) -> int:\n        success_count = 0\n        for user_id in user_ids:\n            if SocketManager.emit_to_user(user_id, event, data):\n                success_count += 1\n        return success_count\n```\n\nEl seguimiento de presencia notifica a los amigos cuando los usuarios se conectan/desconectan. Los eventos de desafío envían actualizaciones en tiempo real mientras los oponentes envían respuestas. Los hilos de soporte permiten chat en vivo entre usuarios y admins con indicadores de escritura. El frontend implementa hooks correspondientes para manejo de eventos con tipado seguro y lógica de reconexión automática.\n\n## Estrategia de Caché\n\nRedis maneja múltiples patrones de caché. Los datos de usuario se cachean con serialización pickle/base64 para objetos Python complejos, usando un patrón de clave `user_cache:{id}` con expiración basada en TTL. El caché de rankings almacena el estado anterior junto con los rankings actuales, permitiendo cálculos de diff eficientes para actualizaciones en vivo. La invalidación de caché se dispara en mutaciones relevantes: las ganancias de XP invalidan el caché de usuario y potencialmente las posiciones en rankings, las compras invalidan el inventario, y así sucesivamente. La capa de caché reduce significativamente la carga de MongoDB en endpoints de alto tráfico como rankings y perfiles de usuario.\n\n## Infraestructura de Testing\n\nLa suite de tests incluye más de 3,000 tests pytest alcanzando 85% de cobertura de código. Los tests abarcan tests unitarios para lógica de negocio, tests de integración para endpoints API, y tests específicos para casos extremos en el motor de gamificación. Los fixtures proporcionan bases de datos de test aisladas y clientes de test autenticados. El pipeline CI ejecuta la suite completa en cada PR, bloqueando merges ante cualquier fallo.\n\n## Calidad de Código y Linting\n\nCada commit pasa por un riguroso proceso de linting: Ruff para linting rápido de Python, Pylint para análisis estático más profundo, MyPy para verificación estricta de tipos, Bandit para escaneo de seguridad, ESLint para TypeScript/React, Stylelint para SCSS, y `tsc --noEmit` para verificación de tipos del frontend. El formateo de código usa YAPF en lugar de Black. YAPF ofrece significativamente más granularidad de configuración para preferencias de formateo, aunque requiere más configuración. El compromiso vale la pena por un estilizado consistente y opinionado en todo el código.\n\n## Pipeline CI/CD\n\nEl flujo de deployment está completamente automatizado. Hacer push a cualquier rama dispara GitHub Actions para crear un PR automáticamente. El PR ejecuta jobs de lint en paralelo usando una estrategia matrix en todos los linters, luego ejecuta la suite de tests completa. Al pasar todas las verificaciones, el PR se mergea automáticamente a la rama prod. Un runner self-hosted en el servidor de producción detecta el merge y dispara `deploy.yml`, que reconstruye solo los contenedores modificados y realiza un reinicio rolling. Los webhooks de Slack notifican en cada etapa: PR creado, verificaciones iniciadas, verificaciones pasadas/fallidas, merge completado, deployment iniciado, deployment exitoso. El flujo completo desde push hasta producción toma menos de 25 minutos sin intervención manual.\n\n## Infraestructura y DevOps\n\nProducción corre en Docker Compose con servicios que incluyen la aplicación Flask bajo uWSGI, Nginx como reverse proxy, Redis con hardening de seguridad, workers Celery para tareas en background, MongoDB, MinIO para almacenamiento de objetos, y Ollama para inferencia LLM local. uWSGI fue elegido sobre Gunicorn deliberadamente. Para aplicaciones más simples, la facilidad de uso de Gunicorn gana. Pero a esta escala, las opciones de configuración granular de uWSGI para gestión de workers, enrutamiento de solicitudes y límites de recursos proporcionan un control que Gunicorn no puede igualar.\n\nCloudflare Tunnels maneja el ingreso sin exponer puertos. Uptime Kuma monitorea todos los servicios con alertas a Slack. Portainer proporciona UI de gestión de contenedores. Autoheal reinicia automáticamente contenedores no saludables. La configuración maneja picos de tráfico sin problemas mientras mantiene los costos de infraestructura mínimos en un solo servidor.\n\nEl stack también incluye PostgreSQL, usado específicamente para un sistema de referidos de Stripe personalizado que publiqué como paquete PyPI. El paquete implementa seguimiento de referidos con estructuras de recompensa configurables, usando adaptadores PostgreSQL para persistencia. Esto significa que el entorno de producción ejecuta tanto MongoDB (almacén de datos principal) como PostgreSQL (subsistema de referidos), aunque sirven propósitos distintos.\n\n## Arquitectura Frontend\n\nAmbas aplicaciones React usan TypeScript en modo estricto sin escapes `any`. TanStack Query maneja todo el estado del servidor con invalidación de caché apropiada, actualizaciones optimistas y error boundaries. Zustand gestiona el estado UI y tokens de autenticación con persistencia. Los módulos SCSS proporcionan estilos con scope sin overhead de runtime de CSS-in-JS.\n\nLa seguridad de tipos se extiende a las respuestas API a través de validación en runtime:\n\n```typescript\nexport const useSendChallenge = (): UseMutationResult<\n  SendChallengeResponse,\n  AxiosError,\n  SendChallengeRequest\n> => {\n  const queryClient = useQueryClient();\n  return useMutation<SendChallengeResponse, AxiosError, SendChallengeRequest>({\n    meta: { skipGlobalErrorHandler: true },\n    mutationFn: async (data: SendChallengeRequest): Promise<SendChallengeResponse> => {\n      const response = await socialMutations.sendChallenge(data);\n      if (!isValidSendChallengeResponse(response)) {\n        throw new Error(SOCIAL_ERROR_MESSAGES.INVALID_SEND_CHALLENGE_RESPONSE);\n      }\n      return response;\n    },\n    onSuccess: (): void => {\n      toast.success('Challenge sent successfully!');\n    },\n    onSettled: async (): Promise<void> => {\n      await queryClient.invalidateQueries({\n        queryKey: socialQueryKeys.challengesList(),\n        refetchType: 'active',\n      });\n    },\n    onError: createApiErrorHandler(SOCIAL_ERROR_CONTEXTS.SEND_CHALLENGE),\n  });\n};\n```\n\nLos type guards como `isValidSendChallengeResponse` validan respuestas API en runtime, capturando violaciones de contrato del backend antes de que se propaguen a través de la UI. Los handlers de error personalizados proporcionan mensajes de error consistentes para el usuario mientras registran detalles para depuración.\n\n## Integración WebSocket Frontend\n\nLa capa socket refleja los patrones del backend con un cliente singleton y hooks tipados:\n\n```typescript\nexport function useSocketEvent<K extends keyof SocketEventMap>(\n  event: K,\n  handler: SocketEventMap[K],\n  deps: React.DependencyList = [],\n): void {\n  const savedHandler = useRef<SocketEventMap[K]>(handler);\n  \n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    const eventHandler = ((...args: unknown[]): void => {\n      (savedHandler.current as (...args: unknown[]) => void)(...args);\n    }) as SocketEventMap[K];\n\n    socketClient.on(event, eventHandler);\n    return (): void => {\n      socketClient.off(event, eventHandler);\n    };\n  }, [event, ...deps]);\n}\n```\n\nListeners específicos de dominio como `useSocialSocketListeners` manejan solicitudes de amistad, actualizaciones de desafíos, cambios de presencia y mensajes directos. Cada tipo de evento invalida cachés relevantes de TanStack Query, manteniendo el estado UI sincronizado sin polling. El cliente socket gestiona la reconexión con backoff exponencial y se re-autentica automáticamente al reconectar.\n\n## Herramientas de Aprendizaje\n\nLa plataforma incluye 11 herramientas de aprendizaje interactivas más allá de los tests de práctica estándar. Estas corren en Ollama self-hosted para inferencia local en lugar de llamadas API externas, manteniendo los costos predecibles y los tiempos de respuesta rápidos. Las herramientas van desde generadores de flashcards hasta simulaciones basadas en escenarios, todas integradas con los sistemas de XP y logros.\n",
  "tech_stack": [
    "Python",
    "Flask",
    "Flask-RESTX",
    "Pydantic",
    "MongoDB",
    "MongoEngine",
    "Redis",
    "Celery",
    "PostgreSQL",
    "WebSockets",
    "uWSGI",
    "React",
    "TypeScript",
    "TanStack Query",
    "Zustand",
    "SCSS",
    "React Native",
    "Expo",
    "Docker",
    "Nginx",
    "GitHub Actions",
    "Cloudflare Tunnels"
  ],
  "code_snippet": "class GetUserResponse(BaseModel):\n    \"\"\"Response schema for GET /account/user\"\"\"\n    id: str = Field(..., alias=\"_id\", description=\"User ID\")\n    username: str = Field(..., description=\"Username\")\n    email: str = Field(..., description=\"Email address\")\n    coins: float = Field(..., description=\"Coin balance\")\n    xp: float = Field(..., description=\"XP points\")\n    level: int = Field(..., description=\"Current level\")\n    achievements: list[str] = Field(..., description=\"Achievement IDs\")\n    achievement_counters: dict[str, Any] | None = Field(..., description=\"Achievement counters\")\n    currentAvatar: str | None = Field(..., description=\"Equipped avatar ID\")\n    nameColor: str | None = Field(..., description=\"Name color\")\n    xpBoost: float = Field(..., description=\"XP boost multiplier\")\n    purchasedItems: list[str] = Field(..., description=\"Purchased item IDs\")\n    subscriptionActive: bool = Field(..., description=\"Subscription active\")\n    subscriptionType: str = Field(..., description=\"Subscription type\")\n    subscriptionPlan: str = Field(..., description=\"Subscription plan\")\n    subscriptionStatus: str | None = Field(..., description=\"Subscription status\")\n    subscriptionPlatform: str | None = Field(..., description=\"Platform (stripe/apple)\")\n    current_streak: int = Field(..., description=\"Current daily streak\")\n    longest_streak: int = Field(..., description=\"Longest streak ever\")\n    streak_freeze_count: int = Field(..., description=\"Freezes used this month\")\n    streak_milestones_claimed: list[int] = Field(..., description=\"Claimed milestones\")\n    current_role: str = Field(..., description=\"Role name based on level\")\n    next_role: dict[str, str | int] | None = Field(..., description=\"Next role info\")\n    referralCodeUsed: str | None = Field(..., description=\"Referral code used\")\n    referredBy: str | None = Field(..., description=\"Referrer user ID\")\n    stripeCustomerId: str | None = Field(..., description=\"Stripe customer ID\")\n    stripeSubscriptionId: str | None = Field(..., description=\"Stripe subscription ID\")\n    appleTransactionId: str | None = Field(..., description=\"Apple transaction ID\")\n    stripeConnectAccountId: str | None = Field(..., description=\"Stripe Connect ID\")\n    stripeConnectOnboarded: bool = Field(..., description=\"Connect onboarding done\")\n    stripeConnectPayoutsEnabled: bool = Field(..., description=\"Payouts enabled\")\n    # ... 40+ additional fields for auth, tracking, payments, social",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/CertGames-Core/blob/prod/backend/api/domains/account/schemas/responses.py",
  "github_url": "https://github.com/CarterPerez-dev/CertGames-Core",
  "demo_url": "https://certgames.com",
  "website_url": null,
  "docs_url": "https://certgames.com/api/docs/",
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": "https://apps.apple.com/us/app/comptia-certgames-exam-prep/id6743811522",
  "android_url": null,
  "forks_count": null,
  "display_order": 0,
  "is_complete": true,
  "status": "active",
  "start_date": "2025-10-01",
  "end_date": null,
  "is_featured": true,
  "stars_count": 7,
  "users_count": 1000,
  "downloads_count": 400,
  "banner_url": "project-certgames/banner.webp",
  "thumbnail_url": "project-certgames/thumbnail.webp",
  "screenshots": [
    "project-certgames/screenshot1.webp",
    "project-certgames/screenshot2.webp",
    "project-certgames/screenshot3.webp"
  ]
}
