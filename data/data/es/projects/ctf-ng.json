{
  "slug": "cisa-presidents-cup-ctf",
  "language": "es",
  "title": "Plataforma CTF CISA President's Cup",
  "subtitle": "Backend distribuido de plataforma CTF con scoring en tiempo real y coordinación WebSocket multi-contenedor",
  "description": "Contribuidor principal del backend para la plataforma de competencia anual de ciberseguridad President's Cup de CISA. Diseñé e implementé la arquitectura fundamental incluyendo sistema de notificaciones en tiempo real, motor de scoring, sistema de tickets de soporte, y los patrones de middleware adoptados en todo el codebase. La plataforma maneja usuarios concurrentes a través de contenedores Flask distribuidos en un deployment de Docker Swarm.",
  "technical_details": "## El Problema de Coordinación Distribuida\n\nLa plataforma corre múltiples contenedores Flask detrás de un load balancer. Las implementaciones estándar de WebSocket fallan en esta configuración porque los rooms de Flask-SocketIO están en memoria por proceso. Si Usuario A se conecta al Contenedor 1 y Usuario B se conecta al Contenedor 2, no pueden comunicarse a través de rooms. Cada característica en tiempo real (actualizaciones de leaderboard, notificaciones de scoring, respuestas de tickets de soporte) necesitaba una solución que funcionara a través de límites de contenedor.\n\n## Redis Pub/Sub como Capa de Coordinación\n\nLa solución: cada contenedor mantiene su propia tabla de lookup mapeando IDs de usuario a IDs de sesión socket. Cuando una notificación se dispara, publica a un canal Redis. Cada contenedor recibe el mensaje, verifica \"¿está este usuario conectado a mí?\", y solo emite si tiene una conexión activa. Sin broadcasts desperdiciados, sin gestión de rooms cross-contenedor.\n\n```python\ndef _handle_notification_message(self, message):\n    user_ids = message.get('user_ids', [])\n    event_name = message.get('event_name')\n    data = message.get('data')\n\n    for user_id in user_ids:\n        user_sids = get_user_connections(user_id)  # Lookup local únicamente\n        for sid in user_sids:\n            self.socketio.emit(event_name, data, to=sid)\n```\n\nEl dict `user_connections` es por contenedor. Redis maneja el broadcast, cada contenedor maneja sus propios usuarios. Separación limpia.\n\n## El Bug de Threading de Gunicorn\n\nEn desarrollo, todo funcionaba. En producción con workers gevent de Gunicorn, el thread suscriptor de Redis moría silenciosamente. Dos problemas compuestos: el modelo pre-fork de Gunicorn destruye threads iniciados durante inicialización de app, y el timing del monkey patching de gevent difiere entre dev y prod. La solución fue reemplazar `threading.Thread` con `socketio.start_background_task()`, que auto-selecciona `gevent.spawn()` en modo gevent. Pequeño cambio, horas de debugging para encontrarlo.\n\n## Abstrayendo la Complejidad\n\nEl código de dominio no debería saber sobre Redis o coordinación de contenedores. El `NotificationService` expone métodos simples como `broadcast_attempt_update(event_id, team_id, challenge_id)`. Por debajo resuelve IDs de usuario, publica a Redis, maneja fallos graciosamente. Un compañero de equipo trabajando en el controller de scoring solo llama al método y continúa.\n\n```python\n@staticmethod\ndef broadcast_attempt_update(event_id, team_id, challenge_id, question_id):\n    NotificationService._emit_refetch(\n        path=f\"/ng/events/{event_id}/challenges/{challenge_id}\",\n        team_id=team_id\n    )\n    NotificationService._emit_refetch(\n        path=f\"/ng/events/{event_id}/leaderboard\",\n        event_id=event_id\n    )\n```\n\n## Middleware Basado en Decoradores\n\nCada endpoint necesita auth, validación de input, carga de recursos, y verificación de permisos. Escribir ese boilerplate en cada route handler es propenso a errores y feo. El enfoque que emergió (a través de mucho feedback de PR e iteración con el equipo): decoradores componibles que se apilan limpiamente.\n\n```python\n@user_endpoint(json_required=True)\n@load_event(LoaderType.PARAM)\n@load_challenge(LoaderType.PARAM)\n@load_question(LoaderType.PARAM)\n@load_team_by_user_and_event()\n@check_permissions(PermissionEnum.CAN_PLAY_CHALLENGES)\ndef post(self, event_id, challenge_id, question_id,\n         event, challenge, question, team, current_user, json_data):\n    return submit_answer(event, challenge, question, team, current_user, json_data)\n```\n\nPara cuando el handler corre, auth está verificado, JSON está parseado, todos los modelos están cargados, permisos están verificados. El handler solo hace lógica de negocio. Este patrón se propagó por todo el backend. Loaders de recursos para eventos, equipos, tickets, scores. Decoradores de permisos. Validadores de ownership. Todo componible.\n\n## Framework de Validación\n\nCada modelo necesita validación de input con mensajes de error consistentes. En lugar de verificaciones ad-hoc dispersas en controllers, hay un `BaseValidator` con métodos encadenables y un decorador `@validation_field` que maneja los patrones comunes (verificaciones de required, manejo de None, mensajes de error amigables).\n\n```python\nvalidator = BaseValidator()\nvalidator.validate_string(data, \"name\", max_length=64, required=True)\nvalidator.validate_model_id(data, \"event_id\", \"Event\", required=True)\nvalidator.validate_datetime(data, \"expires_at\", allow_past=False)\nreturn validator.validate()  # Retorna dict limpio o lanza ValidationError\n```\n\nPasada única: valida y extrae datos parseados. El método `validate()` de classmethod de cada modelo usa esto. Forma de error consistente en toda la API.\n\n## Lo Que Aprendí\n\nEsta fue mi primera vez trabajando en algo a esta escala con un equipo real. Los devs senior del proyecto (particularmente los que manejaban DevOps, la compleja orquestación de Docker Swarm, parsing de challenges, gestión de VNC, y más) me enseñaron cómo realmente pensar sobre sistemas distribuidos, no solo construir features. Los patrones de decoradores surgieron del feedback de code review. El framework de validación evolucionó a través de múltiples iteraciones basadas en lo que el equipo realmente necesitaba. Mirando mis PRs tempranos versus los últimos, el crecimiento es vergonzoso pero real. Enviar código que otras personas tienen que mantener cambia cómo lo escribes.",
  "tech_stack": ["Python", "Flask", "Flask-SocketIO", "Redis", "PostgreSQL", "SQLAlchemy", "AWS SES", "AWS S3", "CTFd", "Docker Swarm", "pytest", "Nginx"],
  "github_url": "https://github.com/CyberSkyline/ctf-ng",
  "website_url": "https://presidentscup.cisa.gov/",
  "demo_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "@user_endpoint(json_required=True)\n@load_event(LoaderType.PARAM)\n@load_challenge(LoaderType.PARAM)\n@load_question(LoaderType.PARAM)\n@load_team_by_user_and_event()\n@limiter.limit(\"1 per 1 seconds\")\n@check_permissions(PermissionEnum.CAN_PLAY_CHALLENGES, \"You do not have permission to play challenges.\")\ndef post(\n    self,\n    event_id: int,\n    challenge_id: int,\n    question_id: int,\n    event,\n    challenge,\n    question,\n    team,\n    current_user: User,\n    permissions,\n    json_data,\n    **kwargs,\n):\n    result = submit_answer(\n        event=event,\n        challenge=challenge,\n        question=question,\n        team=team,\n        current_user=current_user,\n        submission=json_data.get(\"submission\", \"\"),\n    )\n    return success_response(result, status_code=201)",
  "code_language": "python",
  "code_filename": "https://github.com/CyberSkyline/ctf-ng/blob/development/backend/ng/scoring/routes/user_routes.py",
  "display_order": 0,
  "is_complete": true,
  "is_featured": true,
  "thumbnail_url": null,
  "banner_url": null,
  "screenshots": null,
  "stars_count": 3,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "status": "active",
  "start_date": "2025-05-01",
  "end_date": null
}
