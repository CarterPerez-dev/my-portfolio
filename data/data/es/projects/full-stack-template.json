{
  "slug": "fullstack-template",
  "language": "es",
  "title": "Full Stack Template",
  "subtitle": "Construido para copiar. Salta directo a los problemas interesantes.",
  "description": "Boilerplate personal para aplicaciones FastAPI + React. Autenticación JWT con rotación de tokens, PostgreSQL async, type safety en ambos lados, configuración Docker y Nginx. Todo lo que me cansé de reconstruir desde cero.",
  "technical_details": "Boilerplate personal que construí para dejar de resolver los mismos problemas. Cada proyecto necesita auth, migraciones de base de datos, configuración Docker y type safety. Esto lo hace una vez para poder saltar directo al trabajo interesante.\n\n## SafeEnum: Almacenando Valores, No Nombres\n\nSQLAlchemy tiene una trampa que la mayoría no conoce hasta que los muerde. Por defecto, almacena los NOMBRES de los enums en la base de datos, no los valores. Renombra `Color.RED` a `Color.LEGACY_RED` y de repente toda tu tabla es ilegible porque la base de datos todavía tiene `RED` almacenado y SQLAlchemy no puede mapearlo de vuelta.\n\nLa solución es `values_callable` para almacenar valores reales, más un `unknown_value` como fallback para que código nuevo pueda leer datos viejos (o viceversa) sin explotar:\n\n```python\nclass SafeEnum(sa.Enum):\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = lambda e: [str(i.value) for i in e]\n        super().__init__(*enums, **kw)\n        self._unknown_value = kw.get(\"unknown_value\")\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise\n```\n\nAhora renombrar miembros de enums son refactors seguros, no migraciones de base de datos.\n\n## Verificación de Contraseñas Timing-Safe\n\nLos endpoints de login filtran información a través del tiempo de respuesta. Si retornas temprano cuando un usuario no existe, los atacantes pueden enumerar emails válidos midiendo cuánto tardan las requests. La solución es siempre hacer la misma cantidad de trabajo:\n\n```python\nDUMMY_HASH = password_hasher.hash(\"dummy_password_for_timing_attack_prevention\")\n\nasync def verify_password_with_timing_safety(\n    plain_password: str,\n    hashed_password: str | None,\n) -> tuple[bool, str | None]:\n    if hashed_password is None:\n        # El usuario no existe, pero igual hacemos trabajo de argon2\n        await asyncio.to_thread(password_hasher.verify, plain_password, DUMMY_HASH)\n        return False, None\n    return await verify_password(plain_password, hashed_password)\n```\n\nSin importar si el email existe o no, la respuesta tarda lo mismo. También maneja rehashing automático cuando los params de argon2 se actualizan.\n\n## Tracking de Familias de Tokens\n\nLos refresh tokens se roban. La pregunta es qué pasa cuando lo hacen. La mayoría de implementaciones solo verifican si el token es válido. Esta trackea familias de tokens:\n\n```python\nif stored_token.is_revoked:\n    # Token revocado fue reutilizado. Esto es un ataque de replay.\n    # Destruir toda la familia.\n    await RefreshTokenRepository.revoke_family(\n        self.session,\n        stored_token.family_id\n    )\n    raise TokenRevokedError()\n\n# Rotación normal: revocar actual, emitir nuevo con mismo family_id\nawait RefreshTokenRepository.revoke_token(self.session, stored_token)\nnew_token = create_refresh_token(user.id, stored_token.family_id)\n```\n\nCuando refrescas, el token viejo se revoca y uno nuevo se emite con el mismo `family_id`. Si alguien intenta usar un token revocado (atacante replicando un token robado), toda la familia se destruye. El usuario legítimo queda deslogueado, el atacante no obtiene nada.\n\n## Request Queuing en Frontend\n\nMúltiples llamadas API pueden recibir 401 al mismo tiempo. Sin coordinación, cada una intenta refrescar el token independientemente, causando race conditions y requests desperdiciadas. El interceptor pone todo en cola detrás de un único refresh:\n\n```typescript\nif (isRefreshing) {\n  // Otra request ya está refrescando. Poner esta en cola.\n  return new Promise((resolve, reject) => {\n    addRefreshSubscriber(\n      (newToken) => {\n        originalRequest.headers.Authorization = `Bearer ${newToken}`\n        resolve(apiClient(originalRequest))\n      },\n      (error) => reject(error)\n    )\n  })\n}\n\n// La primera request en fallar se convierte en el refresher\nisRefreshing = true\nconst newToken = await handleTokenRefresh()\nprocessRefreshQueue(null, newToken)  // Desbloquear todas las requests en cola\n```\n\nUn refresh, todas las requests pendientes reciben el nuevo token y reintentan automáticamente.\n\n## Zod como Contrato de API\n\nLos tipos de TypeScript desaparecen en runtime. El backend podría retornar basura y `as UserResponse` lo aceptaría felizmente. Los schemas de Zod validan en runtime e infieren los tipos:\n\n```typescript\nexport const isValidUserResponse = (data: unknown): data is UserResponse => {\n  const result = userResponseSchema.safeParse(data)\n  return result.success\n}\n\n// Uso\nconst data: unknown = response.data\nif (!isValidUserResponse(data)) {\n  throw new UserResponseError('Invalid response', endpoint)\n}\n// data ahora está tipado como UserResponse\n```\n\nEl frontend no confía en el backend. Cada respuesta de API se valida antes de usar.\n\n## Toolchain de Rust\n\nLas herramientas de desarrollo corren en Rust. No por razones ideológicas, solo porque es mediblemente más rápido:\n\n- **uv** reemplaza pip y venv. `uv sync` crea `.venv` e instala dependencias en menos de un segundo.\n- **ruff** reemplaza pylint y flake8. El linting pasa en milisegundos.\n- **ty** es el reemplazo de mypy de Astral (diciembre 2025, pre-1.0 pero usable). Misma historia de velocidad.\n- **pnpm**: Reemplaza npm. Usa **content addressable storage** para linkear dependencias desde un único store global, ahorrando gigabytes de disco y haciendo instalaciones casi instantáneas.\n- **biome** reemplaza eslint y prettier. Formateo y linting en una pasada, instantáneo.\n\nNo vas a esperar más de un segundo por ninguna operación de linting o manejo de paquetes.\n\n## Todo lo Demás\n\nSQLAlchemy 2.0 async con configuración de dual engine (async para runtime, sync para migraciones de Alembic desde el mismo connection string). Argon2id para hashing de contraseñas. Docker Compose con layer caching optimizado. Nginx con manejo de upgrade WebSocket y logging con timestamps para debugging de latencia. Design tokens en SCSS. Stores de Zustand con persistencia. Ningún magic string o number en ningún lugar del codebase.",
  "tech_stack": [
    "FastAPI",
    "SQLAlchemy",
    "PostgreSQL",
    "React",
    "TypeScript",
    "Zod",
    "Docker",
    "Nginx",
    "uv",
    "ruff",
    "pnpm",
    "biome"
  ],
  "github_url": "https://github.com/CarterPerez-dev/fullstack-template",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "def enum_values_callable(enum_class: type[Enum]) -> list[str]:\n    \"\"\"\n    Returns enum VALUES (not names) for SQLAlchemy storage\n\n    Prevents the common trap where SQLAlchemy stores enum NAMES by default,\n    causing database breakage if you rename an enum member\n    \"\"\"\n    return [str(item.value) for item in enum_class]\n\n\nclass SafeEnum(sa.Enum):\n    \"\"\"\n    SQLAlchemy Enum type that stores VALUES and handles unknown values gracefully\n    \"\"\"\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = enum_values_callable\n        super().__init__(*enums, **kw)\n        self._unknown_value = (\n            kw[\"_adapted_from\"]._unknown_value\n            if \"_adapted_from\" in kw else kw.get(\"unknown_value\")\n        )\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/fullstack-template/blob/main/backend/app/core/enums.py",
  "thumbnail_url": "project-full-stack-template/thumbnail.webp",
  "banner_url": "project-full-stack-template/banner.webp",
  "screenshots": null,
  "stars_count": 42,
  "forks_count": 2,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": true,
  "status": "active",
  "start_date": "2025-12-11",
  "end_date": null
}
