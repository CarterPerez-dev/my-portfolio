{
  "slug": "kill-pr0cess-inc",
  "language": "es",
  "title": "kill-pr0cess.inc",
  "subtitle": "Un showcase de performance meta: backend Rust + frontend SolidJS midiendo su propia velocidad",
  "technical_details": "La premisa es deliberadamente circular. Tomar los dos frameworks más rápidos en sus respectivos dominios, Rust con Axum en el backend y SolidJS en el frontend, y luego construir algo cuyo único propósito es mostrar qué tan rápido corre. Es un sitio web sobre sí mismo. La estética oscura no es decorativa; elimina todo excepto los datos, las métricas, la salida cruda de computación observando computación. En algún lugar entre una suite de benchmarks y un proyecto artístico, aunque llamarlo cualquiera de los dos se siente como perder el punto.\n\n```rust\n#[derive(Clone)]\npub struct AppState {\n    pub db_pool: DatabasePool,\n    pub redis_client: redis::Client,\n    pub github_service: GitHubService,\n    pub fractal_service: FractalService,\n    pub performance_service: PerformanceService,\n    pub cache_service: CacheService,\n    pub config: Config,\n    pub metrics: MetricsCollector,\n}\n```\n\nLa arquitectura del backend sigue patrones estándar de inyección de dependencias. AppState contiene cada servicio que la aplicación necesita: pool de base de datos, cliente Redis, integración GitHub, monitoreo de performance, caching. Los servicios se inicializan una vez al startup y se pasan a través de la extracción de estado de Axum. El servicio de fractales existe puramente para darle al CPU algo intensivo para computar, paralelizado entre cores con Rayon. Todo lo demás soporta el loop central de recolectar métricas sobre el sistema corriendo el código que recolecta las métricas.\n\n```rust\nlet system_perf = SystemPerformance {\n    cpu_usage_percent: system.global_cpu_info().cpu_usage() as f64,\n    memory_usage_percent: ((total - available) / total) * 100.0,\n    load_average_1m: system.load_average().one,\n    load_average_5m: system.load_average().five,\n    uptime_seconds: system.uptime(),\n    active_processes: system.processes().len() as u32,\n};\n```\n\nLos health checks van más profundo que retornar 200 OK. El endpoint prueba conectividad de base de datos, hace ping a Redis, valida rate limits de API de GitHub, y corre una pequeña computación fractal para verificar que el motor funciona. Cada servicio retorna estado healthy, degraded, o unhealthy con tiempos de respuesta. Si el rate limit de GitHub baja del 10%, el sistema se marca como degraded antes de que algo realmente se rompa. Las rutas de performance exponen stats de CPU, memoria, disco, red, más métricas a nivel de aplicación como hit rates de cache y tamaños de connection pool. Telemetría real, no datos mock.\n\n```typescript\nconst filteredRepositories = createMemo(() => {\n  return state.repositories.filter(repo => {\n    if (state.filters.search) {\n      const searchTerm = state.filters.search.toLowerCase();\n      const searchableText = `${repo.name} ${repo.description || ''}`;\n      if (!searchableText.includes(searchTerm)) return false;\n    }\n    if (state.filters.language && repo.language !== state.filters.language) {\n      return false;\n    }\n    return true;\n  });\n});\n```\n\nSolidJS fue elegido específicamente porque no usa un virtual DOM. Las actualizaciones son quirúrgicas, apuntando exactamente a los nodos DOM que cambiaron. Los hooks como useGitHub y usePerformance envuelven stores reactivos con createStore y derivan valores computados con createMemo. Cuando las métricas se actualizan, solo los números se re-renderizan, no todo el dashboard. Combinado con las respuestas API de latencia casi cero de Rust, el resultado es una UI que se siente como si renderizara antes de que preguntaras. Lo cual, dado de qué trata este proyecto, parece apropiado.",
  "description": "one and nun are the only true form of nuetrality because two things are not allowed to exist | lux-t",
  "tech_stack": ["Rust", "Axum", "Tokio", "SQLx", "PostgreSQL", "Redis", "SolidJS", "TypeScript", "Tailwind CSS", "Rayon", "Docker"],
  "github_url": "https://github.com/CarterPerez-dev/kill-pr0cess.inc",
  "demo_url": "https://dihydroxy.nz",
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "thumbnail_url": null,
  "banner_url": null,
  "screenshots": null,
  "code_snippet": "impl AppState {\n    pub async fn health_check(&self) -> Result<serde_json::Value> {\n        let db_status = match sqlx::query(\"SELECT 1 as test\")\n            .fetch_one(&self.db_pool)\n            .await\n        {\n            Ok(_) => \"healthy\",\n            Err(_) => \"unhealthy\",\n        };\n\n        let mut conn = self.redis_client.get_async_connection().await?;\n        let redis_status = match redis::cmd(\"PING\")\n            .query_async::<_, String>(&mut conn)\n            .await\n        {\n            Ok(_) => \"healthy\",\n            Err(_) => \"unhealthy\",\n        };\n\n        let system_info = self.performance_service.get_system_info().await?;\n\n        Ok(serde_json::json!({\n            \"status\": if db_status == \"healthy\" && redis_status == \"healthy\" { \"healthy\" } else { \"unhealthy\" },\n            \"timestamp\": chrono::Utc::now(),\n            \"services\": {\n                \"database\": db_status,\n                \"redis\": redis_status,\n                \"github_api\": \"healthy\",\n                \"fractal_engine\": \"healthy\"\n            },\n            \"system\": {\n                \"cpu_usage\": system_info[\"cpu_usage_percent\"],\n                \"memory_usage\": system_info[\"memory_usage_percent\"],\n                \"uptime_seconds\": system_info[\"uptime_seconds\"]\n            }\n        }))\n    }\n}",
  "code_language": "rust",
  "code_filename": "backend/src/lib.rs",
  "stars_count": null,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "display_order": 50,
  "is_complete": true,
  "is_featured": false,
  "status": "active",
  "start_date": "2025-06-01",
  "end_date": null
}
