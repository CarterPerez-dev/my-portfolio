{
  "slug": "stripe-referral",
  "language": "es",
  "title": "stripe-referral",
  "subtitle": "Paquete de referidos agnóstico de framework con adaptadores de pago intercambiables",
  "description": "Construí esto para CertGames cuando necesitaba tracking de referidos con automatización real de pagos. No encontré un paquete existente que manejara el ciclo completo sin estar atado a Django o algún proveedor de pagos específico, así que extraje lo que construí en un paquete standalone de PyPI. Basado en SQLAlchemy, funciona con cualquier framework web de Python, viene con adaptadores para Stripe Connect, Wise y transferencias bancarias manuales.",
  "technical_details": "El adapter pattern es la abstracción central aquí. Cada proveedor de pagos implementa `PayoutAdapter` con solo dos métodos: `send_payout` y `validate_recipient`. Agregar soporte para Wise significó escribir una clase que llama a su API, sin cambios en la capa de servicios. Los adaptadores retornan resultados TypedDict en lugar de lanzar excepciones para fallos esperados, así que obtienes `PayoutResult(success=False, error=\"...\")` en vez de try/catch por todos lados.\n\n```python\n# El adaptador de Stripe Connect valida que la cuenta existe y puede recibir fondos\naccount = stripe.Account.retrieve(account_id)\nif not account.payouts_enabled:\n    return RecipientValidation(valid=False, error=\"Payouts not enabled\")\n```\n\nLa capa de repositorios mantiene los queries de SQLAlchemy aislados de la lógica de negocio. Cada modelo tiene su propio repositorio con métodos tipados. `ReferralTrackingRepository.get_user_earnings()` retorna un dict con montos totales, pendientes y pagados calculados mediante expresiones `case()` de SQLAlchemy. La capa de servicios llama a los repositorios y nunca toca el ORM directamente, lo cual hizo el unit testing mucho más fácil ya que puedo mockear en el boundary del repositorio.\n\n```python\n# La capa de servicios se mantiene limpia, los repositorios manejan la complejidad de queries\nearnings = tracking_repo.get_user_earnings(user_id)\nreturn UserEarnings(total=earnings[\"total\"], pending=earnings[\"pending\"], paid=earnings[\"paid\"])\n```\n\nLa generación de códigos de referido usa una combinación de `secrets.token_urlsafe` y hashing SHA256 para producir códigos como `REF_A3F2B1_xK9mNp`. El generador recibe un callback de verificación de colisiones así que reintenta automáticamente si un código ya existe. Máximo diez intentos antes de lanzar `CodeGenerationError`. Este patrón mantiene la lógica de generación testeable sin necesitar una base de datos real en los unit tests.\n\n```python\ndef generate_unique_code(user_id: str, program_key: str, check_collision_fn) -> str:\n    for _ in range(CODE_GENERATION_RETRY_ATTEMPTS):\n        code = _generate_code_string(user_id, program_key)\n        if not check_collision_fn(code):\n            return code\n    raise CodeGenerationError(\"Failed after max attempts\")\n```\n\nLa jerarquía de excepciones es bastante granular. Hay un `StripeReferralError` base del que todo hereda, luego errores específicos para cada modo de fallo: `CodeExpiredError`, `CodeMaxUsesReachedError`, `SelfReferralError`, `PayoutAlreadyExistsError`, y como una docena más. Cada excepción acepta kwargs de contexto arbitrarios que se formatean en la representación string. Hace el debugging más fácil cuando puedes ver `CodeExpiredError: Code 'REF_ABC' expired at 2025-01-15 (code=REF_ABC, expires_at=2025-01-15)`.\n\nPydantic maneja toda la validación de input en la capa de schemas. Los modelos de request eliminan whitespace y aplican límites de longitud antes de que los datos lleguen a la capa de servicios. El schema `CreateProgramRequest` valida que los códigos de moneda sean exactamente 3 caracteres y los convierte a mayúsculas automáticamente. Los servicios reciben datos ya validados y retornan resultados TypedDict, manteniendo los boundaries de la API limpios. Las migraciones de Alembic vienen incluidas con el paquete así que los usuarios pueden correr `alembic upgrade head` para configurar las tablas en su base de datos existente.",
  "tech_stack": [
    "Python",
    "SQLAlchemy",
    "Stripe Connect",
    "Pydantic",
    "Alembic",
    "PostgreSQL"
  ],
  "github_url": "https://github.com/CarterPerez-dev/stripe-referral",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": "https://pypi.org/project/stripe-referral/",
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "class PayoutAdapter(ABC):\n    @abstractmethod\n    def send_payout(\n        self,\n        user_id: str,\n        amount: float,\n        currency: str,\n        recipient_data: dict[str, Any],\n    ) -> PayoutResult:\n        \"\"\"Process a payout to the user\"\"\"\n\n    @abstractmethod\n    def validate_recipient(\n        self,\n        recipient_data: dict[str, Any]\n    ) -> RecipientValidation:\n        \"\"\"Validate recipient data before attempting payout\"\"\"",
  "code_language": "python",
  "code_filename": "src/stripe_referral/adapters/base.py",
  "banner_url": null,
  "thumbnail_url": null, 
  "screenshots": null,
  "stars_count": 3,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": false,
  "status": "active",
  "start_date": "2025-11-20",
  "end_date": null
}
