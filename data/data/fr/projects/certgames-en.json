{
  "slug": "certgames",
  "language": "fr",
  "title": "CertGames",
  "subtitle": "SaaS full stack de formation gamifiée avec composition middleware personnalisée, multijoueur temps réel et CI/CD en production",
  "description": "Une plateforme SaaS de production pour la préparation gamifiée aux certifications de cybersécurité, offrant plus de 15 000 questions de pratique sur 14 certifications, défis multijoueur temps réel et un système de gamification complet avec plus de 120 niveaux, accomplissements et séries.",
  "technical_details": "# SaaS en Production Construit en Solo\n\nCertGames représente plus de 3 000 heures de développement solo, passant d'un projet annexe à un monolithe de production servant plus de 1 000 utilisateurs avec de véritables revenus récurrents mensuels. La plateforme héberge plus de 15 000 questions de pratique sur 14 certifications de cybersécurité, un moteur de gamification avec 120 niveaux, accomplissements, séries quotidiennes et une économie virtuelle. Cet article se concentre sur l'architecture et les décisions d'ingénierie plutôt que sur les fonctionnalités.\n\n## Pourquoi Flask Plutôt que FastAPI?\n\nLa réponse honnête: Flask avait plus de sens quand ceci a commencé comme un petit projet qui ne justifiait pas la surcharge de FastAPI. Quand c'est devenu un monolithe, refactoriser aurait signifié tout reconstruire. Au lieu de ça, j'ai construit mon propre équivalent FastAPI dans Flask. Des décorateurs personnalisés répliquent les patterns d'injection de dépendances de FastAPI, Pydantic gère toute la validation requête/réponse, gevent fournit le patching async pour I/O concurrent, et le système de composition de décorateurs offre la même configuration de route déclarative. À ce stade, les capacités du framework correspondent à FastAPI tout en maintenant la compatibilité écosystème de Flask.\n\n## Architecture Monorepo\n\nLa codebase couvre trois frontends et une seule application Flask qui héberge deux systèmes architecturalement distincts. L'app orientée utilisateur (`frontend/user-app`) et le tableau de bord admin (`frontend/admin-app`) sont des applications React TypeScript séparées, les deux servies via Nginx avec routage basé sur le chemin. Une app iOS (`frontend/ios-app`) construite avec React Native et Expo/EAS partage la même API. Bien que le backend tourne comme une instance Flask unique, les côtés admin et utilisateur maintiennent des structures de routes séparées, patterns de décorateurs et organisations de domaine - le système admin seul rivalise avec la plupart des applications autonomes en portée.\n\nL'API admin seule démontre l'échelle: plus de 20 domaines suivant une structure DDD propre où chaque domaine contient `routes.py`, `services.py`, `queries.py`, `schemas.py`, `controllers.py` et `nsdocs.py` pour la documentation Swagger. Chaque domaine inclut aussi des répertoires `metadata/` documentant les nuances, flux de données et points d'intégration avec autres domaines. Le répertoire `admin/models/` héberge des modèles à travers des catégories comme utilisateurs, contenu, analytics et modération. Cette séparation garde la logique admin isolée tout en partageant l'infrastructure centrale.\n\n## Système de Composition de Décorateurs\n\nLa couche API utilise une pile de décorateurs personnalisée qui compose le middleware de manière déclarative. Une route typique ressemble à:\n\n```python\n@content_ns.route(\"/daily/question/answer\")\nclass DailyQuestionAnswerAPI(Resource):\n    @content_ns.doc(**SUBMIT_DAILY_ANSWER_DOC)\n    @current_app.limiter.limit(\"150/minute, 5000/hour\")\n    @SecOps(\n        RL(\"50/M\"),\n        PG(LVL=\"M\", CX=\"AU\"),\n        RS(MX=\"500KB\", MXP=15),\n        TracingGuard(\"detailed\")\n    )\n    @api_endpoint(\n        auth=True,\n        subscription=True,\n        audit=False,\n        json_body=True\n    )\n    @S(SubmitDailyAnswerRequest)\n    @G(load_daily_question)\n    @R(check_not_already_answered)\n    @CertGamesAPI(SubmitDailyAnswerResponse)\n    def post(self):\n        \"\"\"\n        Submit answer to daily question (premium)\n        \"\"\"\n        return submit_daily_question_answer(), 200\n```\n\nChaque décorateur gère une préoccupation spécifique: `@api_endpoint` gère la vérification auth, vérifications d'abonnement, journalisation d'audit et parsing du corps de requête. `@S` (Schema) valide le corps de requête contre un modèle Pydantic. `@G` (Getter) charge les données requises et les injecte dans l'objet `g` de Flask. `@R` (Requirement) applique les règles métier comme guards. `@CertGamesAPI` enveloppe la réponse dans une enveloppe cohérente avec validation Pydantic. Cette composition laisse les routes déclarer leurs exigences sans boilerplate.\n\n## Architecture d'Authentification\n\nLe système auth implémente une chaîne de repli à trois couches pour compatibilité maximale. L'authentification primaire utilise des tokens JWT validés via Flask-JWT-Extended. Si la validation JWT échoue ou aucun token n'existe, le système revient à l'auth basée session vérifiant `session.get('userId')`. Comme échappatoire finale pour cas limites comme connexions WebSocket depuis certains clients, le système accepte un en-tête `X-User-Id`. Chaque repli journalise la méthode auth utilisée pour débogage.\n\nTrois fournisseurs OAuth offrent inscription sans mot de passe: GitHub, Google et Apple Sign-In. Chaque flux fournisseur gère l'échange de token, extraction de données de profil et liaison de compte pour utilisateurs existants.\n\nL'authentification admin se synchronise avec le système utilisateur principal. Quand un admin se connecte, le système valide contre la collection User, vérifie les privilèges admin, puis crée une session miroir dans le contexte admin. Cette approche unifiée signifie que les admins utilisent les mêmes credentials à travers les deux applications tout en maintenant des stores de session séparés et pistes d'audit.\n\n## Limitation de Taux Quadruple-Couche\n\nLa limitation de taux opère à travers quatre couches sans impact de performance mesurable. La première couche est un `SecureRateLimiter` personnalisé basé sur Redis qui empreinte digitalement les clients utilisant une combinaison d'IP, hash user agent et ID utilisateur authentifié. Il implémente des périodes de pénalité pour récidivistes et suit les patterns à travers les requêtes. La deuxième couche utilise Flask-Limiter pour limites déclaratives par route. La troisième couche est un limiteur de repli global attrapant tout ce qui glisse à travers les règles spécifiques aux routes. La quatrième couche est la limitation de taux Nginx au niveau proxy inverse, fournissant la dernière ligne de défense avant que les requêtes n'atteignent même l'application.\n\n## Fonctionnalités de Plateforme Sociale\n\nAu-delà de la préparation aux certifications, CertGames fonctionne comme une plateforme sociale. Les utilisateurs ont des profils publics avec avatars personnalisables et couleurs de nom achetées via l'économie virtuelle. Le système d'amis supporte l'envoi/acceptation de requêtes, visualisation du statut en ligne et défis d'amis en quiz tête-à-tête sur n'importe quelle certification. Un système de messagerie temps réel permet la communication directe entre amis. Les tableaux de classement publics classent les utilisateurs par XP, niveau et performance spécifique à la certification. Ces fonctionnalités sociales génèrent engagement et rétention au-delà de la fonctionnalité d'étude pure.\n\n## Moteur de Gamification\n\nL'expérience d'étude centrale couvre 14 certifications de cybersécurité, chacune avec 10 niveaux de difficulté allant de \"très facile\" à \"nucléaire\" avec 100 questions par niveau. Deux modes existent: le mode pratique fournit un feedback immédiat après chaque question, tandis que le mode examen imite les vrais examens de certification avec sessions chronométrées et résultats montrés seulement à la fin. Les réponses correctes octroient 5 pièces et 10 XP, avec boosts XP achetables multipliant les gains.\n\nL'économie virtuelle se centre sur une boutique offrant avatars, couleurs de nom, boosts XP et gels de série. Les utilisateurs gagnent des pièces via activité quotidienne, accomplissements et une Question Quotidienne Basée sur Performance qui octroie 250 pièces pour résoudre un scénario pratique. Les titres de rôle progressent à travers niveaux comme \"APT-29 II\", \"Admiral IV\" et ultimement \"Unit 8200\" au niveau max, affichés sur profils et tableaux de classement. Certaines couleurs de nom se déverrouillent automatiquement à niveaux jalons tandis que d'autres nécessitent achat.\n\nLes séries suivent les jours consécutifs d'activité avec récompenses jalons tout du long - 7 jours, 30 jours, 90 jours, 365 jours et plus. Les gels de série achetés depuis la boutique protègent contre la perte de progression. Cinquante accomplissements couvrent tout depuis répondre à des questions jusqu'aux interactions sociales jusqu'à compléter des défis. Quatre jeux interactifs fournissent variété au-delà du quiz standard. Une newsletter quotidienne délivre conseils d'étude, conseils carrière, actualités cybersécurité et décompositions d'outils pentesting, bien que les utilisateurs doivent trouver l'inscription via un easter egg.\n\n## Monétisation et Paiements\n\nLa plateforme opère sur un modèle freemium à 9,99$/mois. Les utilisateurs gratuits accèdent à des questions de pratique quotidiennes limitées tandis que les abonnés déverrouillent accès illimité à plus de 15 000 questions sur 14 certifications, tous niveaux de difficulté, 11 outils d'apprentissage, PBQs quotidiennes, jeux et fonctionnalités premium. Les paiements web traitent via Stripe avec gestion d'abonnement, mises à jour de méthode de paiement et gestion d'annulation. Les paiements iOS utilisent le système d'Achat In-App d'Apple avec intégration StoreKit personnalisée et validation de reçu côté serveur plutôt que solutions tierces comme RevenueCat.\n\nUn système de parrainage récompense les utilisateurs 50% de chaque abonnement référé - continuellement, pas juste le premier mois. Le suivi de parrainage, distribution de récompenses et infrastructure de paiement vivent dans un service PostgreSQL séparé que j'ai publié comme package PyPI. Les paiements supportent plusieurs méthodes incluant PayPal, Venmo, Cash App, Zelle, virement bancaire direct et Stripe Connect pour utilisateurs qui préfèrent les paiements instantanés. Les gestionnaires webhook de Stripe et Apple gèrent les changements d'état d'abonnement, renouvellements, annulations et échecs de paiement.\n\n## Architecture WebSocket Temps Réel\n\nLa couche WebSocket utilise Flask-SocketIO avec une architecture basée sur les salles. Chaque utilisateur authentifié rejoint automatiquement sa salle personnelle (`user_{id}`) à la connexion. Le singleton `SocketManager` fournit une API propre pour émettre des événements:\n\n```python\nclass SocketManager:\n    @staticmethod\n    def emit_to_user(user_id: str, event: str, data: Mapping[str, Any]) -> bool:\n        socketio = SocketManager._get_socketio()\n        if not socketio:\n            return False\n        room = SocketManager.get_user_room(user_id)\n        socketio.emit(event, data, room=room)\n        return True\n\n    @staticmethod\n    def emit_to_users(user_ids: list[str], event: str, data: Mapping[str, Any]) -> int:\n        success_count = 0\n        for user_id in user_ids:\n            if SocketManager.emit_to_user(user_id, event, data):\n                success_count += 1\n        return success_count\n```\n\nLe suivi de présence notifie les amis quand les utilisateurs viennent en ligne/hors ligne. Les événements de défi poussent des mises à jour temps réel quand les adversaires soumettent des réponses. Les fils de support permettent le chat live entre utilisateurs et admins avec indicateurs de frappe. Le frontend implémente des hooks correspondants pour gestion d'événements type-safe avec logique de reconnexion automatique.\n\n## Stratégie de Mise en Cache\n\nRedis gère plusieurs patterns de mise en cache. Les données utilisateur cachent avec sérialisation pickle/base64 pour objets Python complexes, utilisant un pattern de clé `user_cache:{id}` avec expiration basée TTL. La mise en cache de tableau de classement stocke l'état précédent aux côtés des classements actuels, permettant des calculs de diff efficaces pour mises à jour live. L'invalidation de cache se déclenche sur mutations pertinentes: les gains XP invalident le cache utilisateur et potentiellement les positions de tableau de classement, les achats invalident l'inventaire, etc. La couche de mise en cache réduit significativement la charge MongoDB sur les endpoints à haut trafic comme tableaux de classement et profils utilisateur.\n\n## Infrastructure de Tests\n\nLa suite de tests inclut plus de 3 000 tests pytest atteignant 85% de couverture de code. Les tests couvrent tests unitaires pour logique métier, tests d'intégration pour endpoints API et tests spécifiques pour cas limites dans le moteur de gamification. Les fixtures fournissent bases de données de test isolées et clients de test authentifiés. Le pipeline CI exécute la suite complète sur chaque PR, bloquant les merges sur n'importe quel échec.\n\n## Qualité de Code et Linting\n\nChaque commit passe à travers un gant de linting agressif: Ruff pour linting Python rapide, Pylint pour analyse statique plus profonde, MyPy pour vérification de type stricte, Bandit pour scanning de sécurité, ESLint pour TypeScript/React, Stylelint pour SCSS, et `tsc --noEmit` pour vérification de type frontend. Le formatage de code utilise YAPF plutôt que Black. YAPF offre significativement plus de granularité de configuration pour les préférences de formatage, bien qu'il nécessite plus de setup. Le compromis en vaut la peine pour un style cohérent et opiniâtre à travers la codebase.\n\n## Pipeline CI/CD\n\nLe flux de déploiement est entièrement automatisé. Pousser vers n'importe quelle branche déclenche GitHub Actions pour créer une PR automatiquement. La PR exécute des jobs de lint parallèles utilisant une stratégie matricielle à travers tous les linters, puis exécute la suite de tests complète. Sur tous les checks passant, la PR auto-merge vers la branche prod. Un runner auto-hébergé sur le serveur de production détecte le merge et déclenche `deploy.yml`, qui reconstruit seulement les conteneurs changés et effectue un redémarrage progressif. Les webhooks Slack notifient à chaque étape: PR créée, checks démarrés, checks passés/échoués, merge complet, déploiement démarré, déploiement réussi. Le flux entier depuis push à production prend moins de 25 minutes avec zéro intervention manuelle.\n\n## Infrastructure et DevOps\n\nLa production tourne sur Docker Compose avec services incluant l'app Flask sous uWSGI, Nginx comme proxy inverse, Redis avec durcissement de sécurité, workers Celery pour tâches en arrière-plan, MongoDB, MinIO pour stockage objet et Ollama pour inférence LLM locale. uWSGI a été choisi plutôt que Gunicorn délibérément. Pour applications plus simples, la facilité d'utilisation de Gunicorn gagne. Mais à cette échelle, les options de configuration granulaires d'uWSGI pour gestion de workers, routage de requêtes et limites de ressources fournissent un contrôle que Gunicorn ne peut égaler.\n\nCloudflare Tunnels gèrent l'ingress sans exposer de ports. Uptime Kuma surveille tous les services avec alertes Slack. Portainer fournit une UI de gestion de conteneurs. Autoheal redémarre automatiquement les conteneurs non sains. La configuration gère les pics de trafic gracieusement tout en gardant les coûts d'infrastructure minimaux sur un serveur unique.\n\nLa pile inclut aussi PostgreSQL, utilisé spécifiquement pour un système de parrainage Stripe personnalisé que j'ai publié comme package PyPI. Le package implémente le suivi de parrainage avec structures de récompense configurables, utilisant des adaptateurs PostgreSQL pour persistance. Cela signifie que l'environnement de production exécute à la fois MongoDB (datastore primaire) et PostgreSQL (sous-système parrainage), bien qu'ils servent des objectifs distincts.\n\n## Architecture Frontend\n\nLes deux applications React utilisent TypeScript en mode strict sans échappements `any`. TanStack Query gère tout l'état serveur avec invalidation de cache propre, mises à jour optimistes et limites d'erreur. Zustand gère l'état UI et tokens auth avec persistance. Les modules SCSS fournissent style scopé sans surcharge runtime de CSS-in-JS.\n\nLa sécurité des types s'étend aux réponses API via validation runtime:\n\n```typescript\nexport const useSendChallenge = (): UseMutationResult<\n  SendChallengeResponse,\n  AxiosError,\n  SendChallengeRequest\n> => {\n  const queryClient = useQueryClient();\n  return useMutation<SendChallengeResponse, AxiosError, SendChallengeRequest>({\n    meta: { skipGlobalErrorHandler: true },\n    mutationFn: async (data: SendChallengeRequest): Promise<SendChallengeResponse> => {\n      const response = await socialMutations.sendChallenge(data);\n      if (!isValidSendChallengeResponse(response)) {\n        throw new Error(SOCIAL_ERROR_MESSAGES.INVALID_SEND_CHALLENGE_RESPONSE);\n      }\n      return response;\n    },\n    onSuccess: (): void => {\n      toast.success('Challenge sent successfully!');\n    },\n    onSettled: async (): Promise<void> => {\n      await queryClient.invalidateQueries({\n        queryKey: socialQueryKeys.challengesList(),\n        refetchType: 'active',\n      });\n    },\n    onError: createApiErrorHandler(SOCIAL_ERROR_CONTEXTS.SEND_CHALLENGE),\n  });\n};\n```\n\nLes guards de type comme `isValidSendChallengeResponse` valident les réponses API à l'exécution, attrapant les violations de contrat backend avant qu'elles ne se propagent via l'UI. Les gestionnaires d'erreur personnalisés fournissent des messages d'erreur cohérents orientés utilisateur tout en journalisant les détails pour débogage.\n\n## Intégration WebSocket Frontend\n\nLa couche socket miroir patterns backend avec client singleton et hooks typés:\n\n```typescript\nexport function useSocketEvent<K extends keyof SocketEventMap>(\n  event: K,\n  handler: SocketEventMap[K],\n  deps: React.DependencyList = [],\n): void {\n  const savedHandler = useRef<SocketEventMap[K]>(handler);\n  \n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    const eventHandler = ((...args: unknown[]): void => {\n      (savedHandler.current as (...args: unknown[]) => void)(...args);\n    }) as SocketEventMap[K];\n\n    socketClient.on(event, eventHandler);\n    return (): void => {\n      socketClient.off(event, eventHandler);\n    };\n  }, [event, ...deps]);\n}\n```\n\nLes écouteurs spécifiques au domaine comme `useSocialSocketListeners` gèrent requêtes d'ami, mises à jour de défi, changements de présence et messages directs. Chaque type d'événement invalide les caches TanStack Query pertinents, gardant l'état UI synchronisé sans polling. Le client socket gère la reconnexion avec backoff exponentiel et se ré-authentifie automatiquement à la reconnexion.\n\n## Outils d'Apprentissage\n\nLa plateforme inclut 11 outils d'apprentissage interactifs au-delà des tests de pratique standard. Ceux-ci tournent sur Ollama auto-hébergé pour inférence locale plutôt qu'appels API externes, gardant les coûts prévisibles et les temps de réponse rapides. Les outils vont de générateurs de flashcards à simulations basées sur scénarios, tous intégrés avec les systèmes XP et accomplissement.",
  "tech_stack": [
    "Python",
    "Flask",
    "Flask-RESTX",
    "Pydantic",
    "MongoDB",
    "MongoEngine",
    "Redis",
    "Celery",
    "PostgreSQL",
    "WebSockets",
    "uWSGI",
    "React",
    "TypeScript",
    "TanStack Query",
    "Zustand",
    "SCSS",
    "React Native",
    "Expo",
    "Docker",
    "Nginx",
    "GitHub Actions",
    "Cloudflare Tunnels"
  ],
  "code_snippet": "class GetUserResponse(BaseModel):\n    \"\"\"Response schema for GET /account/user\"\"\"\n    id: str = Field(..., alias=\"_id\", description=\"User ID\")\n    username: str = Field(..., description=\"Username\")\n    email: str = Field(..., description=\"Email address\")\n    coins: float = Field(..., description=\"Coin balance\")\n    xp: float = Field(..., description=\"XP points\")\n    level: int = Field(..., description=\"Current level\")\n    achievements: list[str] = Field(..., description=\"Achievement IDs\")\n    achievement_counters: dict[str, Any] | None = Field(..., description=\"Achievement counters\")\n    currentAvatar: str | None = Field(..., description=\"Equipped avatar ID\")\n    nameColor: str | None = Field(..., description=\"Name color\")\n    xpBoost: float = Field(..., description=\"XP boost multiplier\")\n    purchasedItems: list[str] = Field(..., description=\"Purchased item IDs\")\n    subscriptionActive: bool = Field(..., description=\"Subscription active\")\n    subscriptionType: str = Field(..., description=\"Subscription type\")\n    subscriptionPlan: str = Field(..., description=\"Subscription plan\")\n    subscriptionStatus: str | None = Field(..., description=\"Subscription status\")\n    subscriptionPlatform: str | None = Field(..., description=\"Platform (stripe/apple)\")\n    current_streak: int = Field(..., description=\"Current daily streak\")\n    longest_streak: int = Field(..., description=\"Longest streak ever\")\n    streak_freeze_count: int = Field(..., description=\"Freezes used this month\")\n    streak_milestones_claimed: list[int] = Field(..., description=\"Claimed milestones\")\n    current_role: str = Field(..., description=\"Role name based on level\")\n    next_role: dict[str, str | int] | None = Field(..., description=\"Next role info\")\n    referralCodeUsed: str | None = Field(..., description=\"Referral code used\")\n    referredBy: str | None = Field(..., description=\"Referrer user ID\")\n    stripeCustomerId: str | None = Field(..., description=\"Stripe customer ID\")\n    stripeSubscriptionId: str | None = Field(..., description=\"Stripe subscription ID\")\n    appleTransactionId: str | None = Field(..., description=\"Apple transaction ID\")\n    stripeConnectAccountId: str | None = Field(..., description=\"Stripe Connect ID\")\n    stripeConnectOnboarded: bool = Field(..., description=\"Connect onboarding done\")\n    stripeConnectPayoutsEnabled: bool = Field(..., description=\"Payouts enabled\")\n    # ... 40+ additional fields for auth, tracking, payments, social",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/CertGames-Core/blob/prod/backend/api/domains/account/schemas/responses.py",
  "github_url": "https://github.com/CarterPerez-dev/CertGames-Core",
  "website_url": "https://certgames.com",
  "demo_url": null,
  "docs_url": "https://certgames.com/api/docs/",
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": "https://apps.apple.com/us/app/comptia-certgames-exam-prep/id6743811522",
  "android_url": null,
  "forks_count": null,
  "display_order": 0,
  "is_complete": true,
  "status": "active",
  "start_date": "2025-10-01",
  "end_date": null,
  "is_featured": true,
  "stars_count": 7,
  "users_count": 1000,
  "downloads_count": 400,
  "banner_url": "project-certgames/banner.webp",
  "thumbnail_url": "project-certgames/thumbnail.webp",
  "screenshots": [
    "project-certgames/screenshot1.webp",
    "project-certgames/screenshot2.webp",
    "project-certgames/screenshot3.webp"
  ]
}
