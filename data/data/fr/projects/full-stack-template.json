{
  "slug": "fullstack-template",
  "language": "fr",
  "title": "Full Stack Template",
  "subtitle": "Conçu pour que je puisse copier à partir de là. Passe directement aux problèmes intéressants.",
  "description": "Boilerplate personnel pour applications FastAPI + React. Authentification JWT avec rotation de tokens, PostgreSQL asynchrone, typage strict des deux côtés, configuration Docker et Nginx. Tout ce dont je me suis lassé de reconstruire à partir de zéro.",
  "technical_details": "Boilerplate personnel que j'ai construit pour arrêter de résoudre les mêmes problèmes. Chaque projet nécessite de l'authentification, des migrations de base de données, une configuration Docker et de la sécurité des types. Ceci fait tout ça une fois pour que je puisse passer au travail vraiment intéressant.\n\n## SafeEnum: Stockage des Valeurs, Pas des Noms\n\nSQLAlchemy a un piège que la plupart des gens ne connaissent pas jusqu'à ce qu'il les frappe. Par défaut, il stocke les NOMS d'énums dans la base de données, pas les valeurs. Renommez `Color.RED` en `Color.LEGACY_RED` et soudainement toute votre table est illisible parce que la base de données a toujours `RED` stocké et SQLAlchemy ne peut pas le mapper.\n\nLa solution est `values_callable` pour stocker les valeurs réelles, plus un repli `unknown_value` pour que le nouveau code puisse lire les anciennes données (ou vice versa) sans exploser:\n\n```python\nclass SafeEnum(sa.Enum):\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = lambda e: [str(i.value) for i in e]\n        super().__init__(*enums, **kw)\n        self._unknown_value = kw.get(\"unknown_value\")\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise\n```\n\nMaintenant les renommages de membres d'enum sont des refactorisations sûres, pas des migrations de base de données.\n\n## Vérification de Mot de Passe Résistante au Timing\n\nLes endpoints de connexion fuient des informations via le temps de réponse. Si vous retournez tôt quand un utilisateur n'existe pas, les attaquants peuvent énumérer des emails valides en mesurant combien de temps prennent les requêtes. La solution est de toujours faire la même quantité de travail:\n\n```python\nDUMMY_HASH = password_hasher.hash(\"dummy_password_for_timing_attack_prevention\")\n\nasync def verify_password_with_timing_safety(\n    plain_password: str,\n    hashed_password: str | None,\n) -> tuple[bool, str | None]:\n    if hashed_password is None:\n        # L'utilisateur n'existe pas, mais fait quand même le travail argon2\n        await asyncio.to_thread(password_hasher.verify, plain_password, DUMMY_HASH)\n        return False, None\n    return await verify_password(plain_password, hashed_password)\n```\n\nQue l'email existe ou non, la réponse prend le même temps. Gère aussi le re-hachage automatique quand les paramètres argon2 sont mis à jour.\n\n## Suivi de Famille de Tokens\n\nLes refresh tokens se font voler. La question est ce qui se passe quand ils le sont. La plupart des implémentations vérifient simplement si le token est valide. Celle-ci suit les familles de tokens:\n\n```python\nif stored_token.is_revoked:\n    # Token révoqué a été réutilisé. C'est une attaque par rejeu.\n    # Détruire toute la famille.\n    await RefreshTokenRepository.revoke_family(\n        self.session,\n        stored_token.family_id\n    )\n    raise TokenRevokedError()\n\n# Rotation normale: révoquer l'actuel, émettre un nouveau avec le même family_id\nawait RefreshTokenRepository.revoke_token(self.session, stored_token)\nnew_token = create_refresh_token(user.id, stored_token.family_id)\n```\n\nQuand vous rafraîchissez, l'ancien token est révoqué et un nouveau est émis avec le même `family_id`. Si quelqu'un essaie d'utiliser un token révoqué (attaquant rejouant un token volé), toute la famille est détruite. L'utilisateur légitime est déconnecté, l'attaquant n'obtient rien.\n\n## File d'Attente de Requêtes Frontend\n\nPlusieurs appels API peuvent recevoir 401 en même temps. Sans coordination, chacun essaie de rafraîchir le token indépendamment, causant des conditions de course et des requêtes gaspillées. L'intercepteur met tout en file derrière un seul rafraîchissement:\n\n```typescript\nif (isRefreshing) {\n  // Une autre requête rafraîchit déjà. Mettre celle-ci en file.\n  return new Promise((resolve, reject) => {\n    addRefreshSubscriber(\n      (newToken) => {\n        originalRequest.headers.Authorization = `Bearer ${newToken}`\n        resolve(apiClient(originalRequest))\n      },\n      (error) => reject(error)\n    )\n  })\n}\n\n// La première requête à échouer devient le rafraîchisseur\nisRefreshing = true\nconst newToken = await handleTokenRefresh()\nprocessRefreshQueue(null, newToken)  // Débloquer toutes les requêtes en file\n```\n\nUn rafraîchissement, toutes les requêtes en attente obtiennent le nouveau token et réessaient automatiquement.\n\n## Zod comme Contrat API\n\nLes types TypeScript disparaissent à l'exécution. Le backend pourrait retourner n'importe quoi et `as UserResponse` l'accepterait joyeusement. Les schémas Zod valident à l'exécution et infèrent les types:\n\n```typescript\nexport const isValidUserResponse = (data: unknown): data is UserResponse => {\n  const result = userResponseSchema.safeParse(data)\n  return result.success\n}\n\n// Usage\nconst data: unknown = response.data\nif (!isValidUserResponse(data)) {\n  throw new UserResponseError('Invalid response', endpoint)\n}\n// data est maintenant typé comme UserResponse\n```\n\nLe frontend ne fait pas confiance au backend. Chaque réponse API est validée avant utilisation.\n\n## Chaîne d'Outils Rust\n\nL'outillage de dev tourne sur Rust. Pas pour des raisons idéologiques, juste parce que c'est mesurably plus rapide:\n\n- **uv** remplace pip et venv. `uv sync` crée `.venv` et installe les dépendances en moins d'une seconde.\n- **ruff** remplace pylint et flake8. Le linting se fait en millisecondes.\n- **ty** est le remplacement mypy d'Astral (décembre 2025, pré-1.0 mais utilisable). Même histoire de vitesse.\n- **pnpm**: Remplace npm. Utilise **content addressable storage** pour lier les dépendances depuis un seul magasin global, économisant des gigaoctets d'espace disque et rendant les installations quasi instantanées.\n- **biome** remplace eslint et prettier. Formatage et linting en une passe, instantanément.\n\nVous n'attendrez pas plus d'une seconde pour n'importe quelle opération de linting ou de gestion de paquets.\n\n## Tout le Reste\n\nSQLAlchemy 2.0 asynchrone avec une configuration à double moteur (async pour l'exécution, sync pour les migrations Alembic depuis la même chaîne de connexion). Argon2id pour le hachage de mots de passe. Docker Compose avec mise en cache optimisée des couches. Nginx avec gestion de mise à niveau WebSocket et journalisation chronométrée pour le débogage de latence. Tokens de design SCSS. Stores Zustand avec persistance. Aucune chaîne ou nombre magique nulle part dans le code.",
  "tech_stack": [
    "FastAPI",
    "SQLAlchemy",
    "PostgreSQL",
    "React",
    "TypeScript",
    "Zod",
    "Docker",
    "Nginx",
    "uv",
    "ruff",
    "pnpm",
    "biome"
  ],
  "github_url": "https://github.com/CarterPerez-dev/fullstack-template",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "def enum_values_callable(enum_class: type[Enum]) -> list[str]:\n    \"\"\"\n    Returns enum VALUES (not names) for SQLAlchemy storage\n\n    Prevents the common trap where SQLAlchemy stores enum NAMES by default,\n    causing database breakage if you rename an enum member\n    \"\"\"\n    return [str(item.value) for item in enum_class]\n\n\nclass SafeEnum(sa.Enum):\n    \"\"\"\n    SQLAlchemy Enum type that stores VALUES and handles unknown values gracefully\n    \"\"\"\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = enum_values_callable\n        super().__init__(*enums, **kw)\n        self._unknown_value = (\n            kw[\"_adapted_from\"]._unknown_value\n            if \"_adapted_from\" in kw else kw.get(\"unknown_value\")\n        )\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/fullstack-template/blob/main/backend/app/core/enums.py",
  "thumbnail_url": "project-full-stack-template/thumbnail.webp",
  "banner_url": "project-full-stack-template/banner.webp",
  "screenshots": null,
  "stars_count": 42,
  "forks_count": 2,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": true,
  "status": "active",
  "start_date": "2025-12-11",
  "end_date": null
}
