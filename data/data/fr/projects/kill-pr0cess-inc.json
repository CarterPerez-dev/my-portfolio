{
  "slug": "kill-pr0cess-inc",
  "language": "fr",
  "title": "kill-pr0cess.inc",
  "subtitle": "Une vitrine de performance méta: backend Rust + frontend SolidJS mesurant leur propre vitesse",
  "technical_details": "La prémisse est délibérément circulaire. Prendre les deux frameworks les plus rapides dans leurs domaines respectifs, Rust avec Axum sur le backend et SolidJS sur le frontend, puis construire quelque chose dont le but entier est d'afficher à quelle vitesse ça tourne. C'est un site web sur lui-même. L'esthétique sombre n'est pas décorative; elle enlève tout sauf les données, les métriques, la sortie brute de computation observant la computation. Quelque part entre une suite de benchmarks et un projet d'art, bien qu'appeler ça l'un ou l'autre semble rater le point.\n\n```rust\n#[derive(Clone)]\npub struct AppState {\n    pub db_pool: DatabasePool,\n    pub redis_client: redis::Client,\n    pub github_service: GitHubService,\n    pub fractal_service: FractalService,\n    pub performance_service: PerformanceService,\n    pub cache_service: CacheService,\n    pub config: Config,\n    pub metrics: MetricsCollector,\n}\n```\n\nL'architecture backend suit les patterns d'injection de dépendances standard. AppState détient chaque service dont l'application a besoin: pool de base de données, client Redis, intégration GitHub, surveillance de performance, mise en cache. Les services sont initialisés une fois au démarrage et passés via l'extraction d'état d'Axum. Le service fractal existe purement pour donner au CPU quelque chose d'intensif à calculer, parallélisé à travers les cœurs avec Rayon. Tout le reste supporte la boucle centrale de collecte de métriques sur le système exécutant le code qui collecte les métriques.\n\n```rust\nlet system_perf = SystemPerformance {\n    cpu_usage_percent: system.global_cpu_info().cpu_usage() as f64,\n    memory_usage_percent: ((total - available) / total) * 100.0,\n    load_average_1m: system.load_average().one,\n    load_average_5m: system.load_average().five,\n    uptime_seconds: system.uptime(),\n    active_processes: system.processes().len() as u32,\n};\n```\n\nLes vérifications de santé vont plus profond que retourner 200 OK. L'endpoint teste la connectivité base de données, ping Redis, valide les limites de taux API GitHub et exécute un petit calcul fractal pour vérifier que le moteur fonctionne. Chaque service retourne un statut sain, dégradé ou non sain avec temps de réponse. Si la limite de taux GitHub descend sous 10%, le système se marque dégradé avant que quoi que ce soit ne casse réellement. Les routes de performance exposent les stats CPU, mémoire, disque, réseau, plus métriques au niveau application comme taux de hits cache et tailles de pool de connexions. Vraie télémétrie, pas de données fictives.\n\n```typescript\nconst filteredRepositories = createMemo(() => {\n  return state.repositories.filter(repo => {\n    if (state.filters.search) {\n      const searchTerm = state.filters.search.toLowerCase();\n      const searchableText = `${repo.name} ${repo.description || ''}`;\n      if (!searchableText.includes(searchTerm)) return false;\n    }\n    if (state.filters.language && repo.language !== state.filters.language) {\n      return false;\n    }\n    return true;\n  });\n});\n```\n\nSolidJS a été choisi spécifiquement parce qu'il n'utilise pas de DOM virtuel. Les mises à jour sont chirurgicales, ciblant exactement les nœuds DOM qui ont changé. Les hooks comme useGitHub et usePerformance enveloppent des stores réactifs avec createStore et dérivent des valeurs calculées avec createMemo. Quand les métriques se mettent à jour, seuls les nombres re-render, pas tout le dashboard. Combiné avec les réponses API quasi-zéro latence de Rust, le résultat est une UI qui semble render avant que vous ne demandiez. Ce qui, vu ce qu'est ce projet, semble approprié.",
  "description": "one and nun are the only true form of nuetrality because two things are not allowed to exist | lux-t",
  "tech_stack": ["Rust", "Axum", "Tokio", "SQLx", "PostgreSQL", "Redis", "SolidJS", "TypeScript", "Tailwind CSS", "Rayon", "Docker"],
  "github_url": "https://github.com/CarterPerez-dev/kill-pr0cess.inc",
  "demo_url": "https://dihydroxy.nz",
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "thumbnail_url": null,
  "banner_url": null,
  "screenshots": null,
  "code_snippet": "impl AppState {\n    pub async fn health_check(&self) -> Result<serde_json::Value> {\n        let db_status = match sqlx::query(\"SELECT 1 as test\")\n            .fetch_one(&self.db_pool)\n            .await\n        {\n            Ok(_) => \"healthy\",\n            Err(_) => \"unhealthy\",\n        };\n\n        let mut conn = self.redis_client.get_async_connection().await?;\n        let redis_status = match redis::cmd(\"PING\")\n            .query_async::<_, String>(&mut conn)\n            .await\n        {\n            Ok(_) => \"healthy\",\n            Err(_) => \"unhealthy\",\n        };\n\n        let system_info = self.performance_service.get_system_info().await?;\n\n        Ok(serde_json::json!({\n            \"status\": if db_status == \"healthy\" && redis_status == \"healthy\" { \"healthy\" } else { \"unhealthy\" },\n            \"timestamp\": chrono::Utc::now(),\n            \"services\": {\n                \"database\": db_status,\n                \"redis\": redis_status,\n                \"github_api\": \"healthy\",\n                \"fractal_engine\": \"healthy\"\n            },\n            \"system\": {\n                \"cpu_usage\": system_info[\"cpu_usage_percent\"],\n                \"memory_usage\": system_info[\"memory_usage_percent\"],\n                \"uptime_seconds\": system_info[\"uptime_seconds\"]\n            }\n        }))\n    }\n}",
  "code_language": "rust",
  "code_filename": "backend/src/lib.rs",
  "stars_count": null,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "display_order": 50,
  "is_complete": true,
  "is_featured": false,
  "status": "active",
  "start_date": "2025-06-01",
  "end_date": null
}
