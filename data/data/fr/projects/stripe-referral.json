{
  "slug": "stripe-referral",
  "language": "fr",
  "title": "stripe-referral",
  "subtitle": "Package de parrainage agnostique du framework avec adaptateurs de paiement interchangeables",
  "description": "Construit pour CertGames quand j'avais besoin de suivi de parrainage avec automatisation réelle des paiements. Je ne trouvais pas de package existant gérant le cycle de vie complet sans être lié à Django ou à un fournisseur de paiement spécifique, alors j'ai extrait ce que j'avais construit en un package PyPI autonome. Basé sur SQLAlchemy, fonctionne avec n'importe quel framework web Python, livré avec des adaptateurs pour Stripe Connect, Wise et virements bancaires manuels.",
  "technical_details": "Le pattern adaptateur est l'abstraction centrale ici. Chaque fournisseur de paiement implémente `PayoutAdapter` avec seulement deux méthodes: `send_payout` et `validate_recipient`. L'ajout du support Wise signifiait écrire une classe qui appelle leur API, aucun changement à la couche service. Les adaptateurs retournent des résultats TypedDict au lieu de lever des exceptions pour les échecs attendus, donc vous obtenez `PayoutResult(success=False, error=\"...\")` plutôt que try/catch partout.\n\n```python\n# L'adaptateur Stripe Connect valide que le compte existe et peut recevoir des fonds\naccount = stripe.Account.retrieve(account_id)\nif not account.payouts_enabled:\n    return RecipientValidation(valid=False, error=\"Payouts not enabled\")\n```\n\nLa couche repository garde les requêtes SQLAlchemy isolées de la logique métier. Chaque modèle a son propre repository avec des méthodes typées. `ReferralTrackingRepository.get_user_earnings()` retourne un dict avec les montants total, en attente et payé calculés via les expressions `case()` de SQLAlchemy. La couche service appelle les repositories et ne touche jamais l'ORM directement, ce qui a rendu les tests unitaires beaucoup plus faciles puisque je peux mocker à la frontière du repository.\n\n```python\n# La couche service reste propre, les repositories gèrent la complexité des requêtes\nearnings = tracking_repo.get_user_earnings(user_id)\nreturn UserEarnings(total=earnings[\"total\"], pending=earnings[\"pending\"], paid=earnings[\"paid\"])\n```\n\nLa génération de codes de parrainage utilise une combinaison de `secrets.token_urlsafe` et de hachage SHA256 pour produire des codes comme `REF_A3F2B1_xK9mNp`. Le générateur prend un callback de vérification de collision pour qu'il réessaie automatiquement si un code existe déjà. Dix tentatives maximum avant de lever `CodeGenerationError`. Ce pattern garde la logique de génération testable sans avoir besoin d'une vraie base de données dans les tests unitaires.\n\n```python\ndef generate_unique_code(user_id: str, program_key: str, check_collision_fn) -> str:\n    for _ in range(CODE_GENERATION_RETRY_ATTEMPTS):\n        code = _generate_code_string(user_id, program_key)\n        if not check_collision_fn(code):\n            return code\n    raise CodeGenerationError(\"Failed after max attempts\")\n```\n\nLa hiérarchie d'exceptions est assez granulaire. Il y a une `StripeReferralError` de base dont tout hérite, puis des erreurs spécifiques pour chaque mode d'échec: `CodeExpiredError`, `CodeMaxUsesReachedError`, `SelfReferralError`, `PayoutAlreadyExistsError`, et environ une douzaine d'autres. Chaque exception accepte des kwargs de contexte arbitraires qui sont formatés dans la représentation chaîne. Facilite le débogage quand vous pouvez voir `CodeExpiredError: Code 'REF_ABC' expired at 2025-01-15 (code=REF_ABC, expires_at=2025-01-15)`.\n\nPydantic gère toute la validation d'entrée sur la couche schéma. Les modèles de requête enlèvent les espaces et appliquent des limites de longueur avant que les données n'atteignent la couche service. Le schéma `CreateProgramRequest` valide que les codes de devise font exactement 3 caractères et les met en majuscules automatiquement. Les services reçoivent des données déjà validées et retournent des résultats TypedDict, gardant les frontières API propres. Les migrations Alembic sont livrées avec le package donc les utilisateurs peuvent exécuter `alembic upgrade head` pour configurer les tables dans leur base de données existante.",
  "tech_stack": [
    "Python",
    "SQLAlchemy",
    "Stripe Connect",
    "Pydantic",
    "Alembic",
    "PostgreSQL"
  ],
  "github_url": "https://github.com/CarterPerez-dev/stripe-referral",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": "https://pypi.org/project/stripe-referral/",
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "class PayoutAdapter(ABC):\n    @abstractmethod\n    def send_payout(\n        self,\n        user_id: str,\n        amount: float,\n        currency: str,\n        recipient_data: dict[str, Any],\n    ) -> PayoutResult:\n        \"\"\"Process a payout to the user\"\"\"\n\n    @abstractmethod\n    def validate_recipient(\n        self,\n        recipient_data: dict[str, Any]\n    ) -> RecipientValidation:\n        \"\"\"Validate recipient data before attempting payout\"\"\"",
  "code_language": "python",
  "code_filename": "src/stripe_referral/adapters/base.py",
  "banner_url": null,
  "thumbnail_url": null,
  "screenshots": null,
  "stars_count": 3,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": false,
  "status": "active",
  "start_date": "2025-11-20",
  "end_date": null
}
