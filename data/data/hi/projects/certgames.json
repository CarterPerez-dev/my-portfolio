{
  "slug": "certgames",
  "language": "hi",
  "title": "CertGames",
  "subtitle": "कस्टम middleware composition, रियल-टाइम मल्टीप्लेयर और प्रोडक्शन CI/CD के साथ फुल स्टैक gamified learning SaaS",
  "description": "साइबरसिक्योरिटी सर्टिफिकेशन की gamified तैयारी के लिए एक प्रोडक्शन SaaS प्लेटफॉर्म, जिसमें 14 सर्टिफिकेशन में 15,000+ प्रैक्टिस प्रश्न, रियल-टाइम मल्टीप्लेयर चैलेंज, और 120+ लेवल, achievements और streaks के साथ एक व्यापक gamification सिस्टम शामिल है।",
  "technical_details": "# अकेले बनाया गया प्रोडक्शन SaaS\n\nCertGames 3,000+ घंटों की solo development का प्रतिनिधित्व करता है, जो एक साइड प्रोजेक्ट से बढ़कर 1,000+ users को सर्व करने वाले प्रोडक्शन monolith बन गया है जिसमें वास्तविक monthly recurring revenue है। प्लेटफॉर्म 14 साइबरसिक्योरिटी सर्टिफिकेशन में 15,000+ प्रैक्टिस प्रश्न, 120 लेवल वाला gamification engine, achievements, daily streaks और virtual economy होस्ट करता है। यह writeup features की बजाय architecture और engineering decisions पर केंद्रित है।\n\n## FastAPI की जगह Flask क्यों?\n\nईमानदार जवाब: जब यह एक छोटे प्रोजेक्ट के रूप में शुरू हुआ तब Flask ज्यादा सही था क्योंकि FastAPI का overhead justify नहीं होता था। जब यह monolith बन गया, तो refactoring का मतलब होता सब कुछ दोबारा बनाना। इसके बजाय, मैंने Flask के अंदर अपना खुद का FastAPI equivalent बनाया। Custom decorators FastAPI के dependency injection patterns को replicate करते हैं, Pydantic सभी request/response validation handle करता है, gevent concurrent I/O के लिए async patching प्रदान करता है, और decorator composition system वही declarative route configuration देता है। इस बिंदु पर, framework capabilities FastAPI से मेल खाती हैं जबकि Flask ecosystem compatibility बनी रहती है।\n\n## Monorepo Architecture\n\nCodebase तीन frontends और एक single Flask application में फैला है जो दो architecturally distinct systems को host करता है। User facing app (`frontend/user-app`) और admin dashboard (`frontend/admin-app`) अलग-अलग React TypeScript applications हैं, दोनों Nginx के माध्यम से path based routing से serve होते हैं। React Native और Expo/EAS से बना iOS app (`frontend/ios-app`) same API share करता है। जबकि backend एक Flask instance के रूप में चलता है, admin और user sides अलग route structures, decorator patterns और domain organizations maintain करते हैं - अकेला admin system scope में अधिकांश standalone applications को टक्कर देता है।\n\nसिर्फ admin API ही scale demonstrate करती है: 20+ domains clean DDD structure follow करते हैं जहां हर domain में `routes.py`, `services.py`, `queries.py`, `schemas.py`, `controllers.py` और Swagger documentation के लिए `nsdocs.py` होता है। हर domain में `metadata/` directories भी हैं जो nuances, data flows और अन्य domains के साथ integration points document करती हैं। `admin/models/` directory users, content, analytics और moderation जैसी categories में models host करती है। यह separation admin logic को isolated रखता है जबकि core infrastructure share होती है।\n\n## Decorator Composition System\n\nAPI layer एक custom decorator stack use करती है जो middleware को declaratively compose करता है। एक typical route इस तरह दिखती है:\n\n```python\n@content_ns.route(\"/daily/question/answer\")\nclass DailyQuestionAnswerAPI(Resource):\n    @content_ns.doc(**SUBMIT_DAILY_ANSWER_DOC)\n    @current_app.limiter.limit(\"150/minute, 5000/hour\")\n    @SecOps(\n        RL(\"50/M\"),\n        PG(LVL=\"M\", CX=\"AU\"),\n        RS(MX=\"500KB\", MXP=15),\n        TracingGuard(\"detailed\")\n    )\n    @api_endpoint(\n        auth=True,\n        subscription=True,\n        audit=False,\n        json_body=True\n    )\n    @S(SubmitDailyAnswerRequest)\n    @G(load_daily_question)\n    @R(check_not_already_answered)\n    @CertGamesAPI(SubmitDailyAnswerResponse)\n    def post(self):\n        \"\"\"\n        Submit answer to daily question (premium)\n        \"\"\"\n        return submit_daily_question_answer(), 200\n```\n\nहर decorator एक specific concern handle करता है: `@api_endpoint` auth verification, subscription checks, audit logging और request body parsing manage करता है। `@S` (Schema) request body को Pydantic model के against validate करता है। `@G` (Getter) required data load करता है और इसे Flask के `g` object में inject करता है। `@R` (Requirement) business rules को guards के रूप में enforce करता है। `@CertGamesAPI` response को Pydantic validation के साथ consistent envelope में wrap करता है। यह composition routes को बिना boilerplate के अपनी requirements declare करने देता है।\n\n## Authentication Architecture\n\nAuth system maximum compatibility के लिए three layer fallback chain implement करता है। Primary authentication Flask-JWT-Extended के through validate होने वाले JWT tokens use करती है। अगर JWT validation fail होती है या token नहीं है, system session based auth पर fall back करता है `session.get('userId')` check करके। Certain clients से WebSocket connections जैसे edge cases के लिए final escape hatch के रूप में, system `X-User-Id` header accept करता है। हर fallback debugging के लिए use हुए auth method को log करता है।\n\nतीन OAuth providers passwordless signup offer करते हैं: GitHub, Google और Apple Sign-In। हर provider flow token exchange, profile data extraction और existing users के लिए account linking handle करता है।\n\nAdmin authentication main user system के साथ sync करता है। जब admin login करता है, system User collection के against validate करता है, admin privileges verify करता है, फिर admin context में mirrored session create करता है। यह unified approach मतलब admins दोनों applications में same credentials use करते हैं जबकि separate session stores और audit trails maintain करते हैं।\n\n## Quad-Layer Rate Limiting\n\nRate limiting चार layers पर बिना measurable performance impact के operate करता है। पहली layer एक custom Redis backed `SecureRateLimiter` है जो IP, user agent hash और authenticated user ID के combination से clients को fingerprint करता है। यह repeat offenders के लिए penalty periods implement करता है और requests के across patterns track करता है। दूसरी layer declarative per route limits के लिए Flask-Limiter use करती है। तीसरी layer एक global fallback limiter है जो route specific rules से slip होने वाली किसी भी चीज़ को catch करती है। चौथी layer reverse proxy level पर Nginx rate limiting है, जो requests के application तक पहुंचने से पहले last line of defense provide करती है।\n\n## Social Platform Features\n\nCertification prep के अलावा, CertGames एक social platform के रूप में भी काम करता है। Users के पास public profiles हैं जिनमें virtual economy से खरीदे गए customizable avatars और name colors हैं। Friend system requests भेजना/accept करना, online status देखना और किसी भी certification पर friends को head to head quizzes के लिए challenge करना support करता है। Real-time messaging system friends के बीच direct communication allow करता है। Public leaderboards users को XP, level और certification specific performance से rank करते हैं। ये social features pure study functionality से परे engagement और retention drive करते हैं।\n\n## Gamification Engine\n\nCore study experience 14 cybersecurity certifications span करती है, हर एक में 10 difficulty tiers हैं \"very easy\" से \"nuclear\" तक जिसमें 100 questions per tier हैं। दो modes exist करते हैं: practice mode हर question के बाद immediate feedback provide करता है, जबकि exam mode timed sessions के साथ real certification exams mimic करता है और results सिर्फ completion पर दिखाते हैं। Correct answers 5 coins और 10 XP award करते हैं, purchasable XP boosts gains multiply करते हैं।\n\nVirtual economy एक shop के around center होती है जो avatars, name colors, XP boosts और streak freezes offer करती है। Users daily activity, achievements और daily Performance-Based Question से coins earn करते हैं जो hands on scenario solve करने पर 250 coins award करती है। Role titles tiers से progress करते हैं जैसे \"APT-29 II,\" \"Admiral IV,\" और ultimately max level पर \"Unit 8200\", profiles और leaderboards पर display होते हैं। Certain name colors milestone levels पर automatically unlock होते हैं जबकि others purchase require करते हैं।\n\nStreaks consecutive days of activity track करती हैं milestone rewards के साथ - 7 days, 30 days, 90 days, 365 days और more। Shop से purchased streak freezes progress lose होने से protect करते हैं। Fifty achievements questions answer करने से social interactions से challenges complete करने तक सब cover करते हैं। Four interactive games standard quizzing से परे variety provide करते हैं। Daily newsletter study tips, career advice, cybersecurity news और pentesting tool breakdowns deliver करती है, हालांकि users को signup एक easter egg के through find करनी होती है।\n\n## Monetization और Payments\n\nPlatform $9.99/month पर freemium model पर operate करता है। Free users limited daily practice questions access कर सकते हैं जबकि subscribers 14 certifications में 15,000+ questions का unlimited access, सभी difficulty tiers, 11 learning tools, daily PBQs, games और premium features unlock करते हैं। Web payments subscription management, payment method updates और cancellation handling के साथ Stripe से process होते हैं। iOS payments RevenueCat जैसे third party solutions की बजाय custom StoreKit integration और server side receipt validation के साथ Apple का In-App Purchase system use करते हैं।\n\nReferral system users को हर referred subscription का 50% reward करता है - continuously, सिर्फ first month नहीं। Referral tracking, reward distribution और payout infrastructure एक separate PostgreSQL backed service में live करते हैं जो मैंने PyPI package के रूप में publish किया। Payouts multiple methods support करते हैं including PayPal, Venmo, Cash App, Zelle, direct bank transfer और instant payouts prefer करने वाले users के लिए Stripe Connect। Stripe और Apple दोनों से Webhook handlers subscription state changes, renewals, cancellations और payment failures manage करते हैं।\n\n## Real-Time WebSocket Architecture\n\nWebSocket layer room based architecture के साथ Flask-SocketIO use करती है। हर authenticated user connection पर automatically अपने personal room (`user_{id}`) join करता है। `SocketManager` singleton events emit करने के लिए clean API provide करता है:\n\n```python\nclass SocketManager:\n    @staticmethod\n    def emit_to_user(user_id: str, event: str, data: Mapping[str, Any]) -> bool:\n        socketio = SocketManager._get_socketio()\n        if not socketio:\n            return False\n        room = SocketManager.get_user_room(user_id)\n        socketio.emit(event, data, room=room)\n        return True\n\n    @staticmethod\n    def emit_to_users(user_ids: list[str], event: str, data: Mapping[str, Any]) -> int:\n        success_count = 0\n        for user_id in user_ids:\n            if SocketManager.emit_to_user(user_id, event, data):\n                success_count += 1\n        return success_count\n```\n\nPresence tracking friends को notify करता है जब users online/offline आते हैं। Challenge events opponents के answers submit करने पर real-time updates push करते हैं। Support threads typing indicators के साथ users और admins के बीच live chat enable करते हैं। Frontend automatic reconnection logic के साथ type-safe event handling के लिए corresponding hooks implement करता है।\n\n## Caching Strategy\n\nRedis multiple caching patterns handle करता है। User data complex Python objects के लिए pickle/base64 serialization के साथ cache होता है, `user_cache:{id}` key pattern के साथ TTL based expiration। Leaderboard caching live updates के लिए efficient diff calculations enable करने के लिए current rankings के साथ previous state store करता है। Cache invalidation relevant mutations पर trigger होता है: XP gains user cache invalidate करते हैं और potentially leaderboard positions, purchases inventory invalidate करती हैं, और इसी तरह। Caching layer leaderboards और user profiles जैसे high traffic endpoints पर MongoDB load significantly reduce करती है।\n\n## Testing Infrastructure\n\nTest suite 85% code coverage achieve करते हुए 3,000+ pytest tests include करती है। Tests business logic के लिए unit tests, API endpoints के लिए integration tests और gamification engine में edge cases के लिए specific tests span करते हैं। Fixtures isolated test databases और authenticated test clients provide करते हैं। CI pipeline हर PR पर full suite run करता है, किसी भी failure पर merges block करता है।\n\n## Code Quality और Linting\n\nहर commit एक aggressive linting gauntlet से pass होता है: fast Python linting के लिए Ruff, deeper static analysis के लिए Pylint, strict type checking के लिए MyPy, security scanning के लिए Bandit, TypeScript/React के लिए ESLint, SCSS के लिए Stylelint और frontend type verification के लिए `tsc --noEmit`। Code formatting Black की बजाय YAPF use करता है। YAPF formatting preferences के लिए significantly more configuration granularity offer करता है, हालांकि more setup require करता है। Codebase में consistent, opinionated styling के लिए tradeoff worth है।\n\n## CI/CD Pipeline\n\nDeployment flow fully automated है। किसी भी branch पर push करने से GitHub Actions trigger होकर automatically PR create करती है। PR सभी linters में matrix strategy use करके parallel lint jobs run करता है, फिर full test suite execute करता है। सभी checks pass होने पर, PR auto merge होकर prod branch में जाता है। Production server पर self hosted runner merge detect करता है और `deploy.yml` trigger करता है, जो सिर्फ changed containers rebuild करता है और rolling restart perform करता है। Slack webhooks हर stage पर notify करते हैं: PR created, checks started, checks passed/failed, merge complete, deployment started, deployment succeeded। Push से production तक पूरा flow 25 minutes से कम में होता है बिना किसी manual intervention के।\n\n## Infrastructure और DevOps\n\nProduction Docker Compose पर run होता है services के साथ जिनमें uWSGI के under Flask app, reverse proxy के रूप में Nginx, security hardening के साथ Redis, background tasks के लिए Celery workers, MongoDB, object storage के लिए MinIO और local LLM inference के लिए Ollama शामिल हैं। uWSGI deliberately Gunicorn के ऊपर choose किया गया। Simpler applications के लिए, Gunicorn की ease of use जीतती है। लेकिन इस scale पर, worker management, request routing और resource limits के लिए uWSGI के granular configuration options ऐसा control provide करते हैं जो Gunicorn match नहीं कर सकता।\n\nCloudflare Tunnels ports expose किए बिना ingress handle करते हैं। Uptime Kuma Slack alerting के साथ सभी services monitor करता है। Portainer container management UI provide करता है। Autoheal automatically unhealthy containers restart करता है। Setup single server पर infrastructure costs minimal रखते हुए traffic spikes gracefully handle करता है।\n\nStack में PostgreSQL भी include है, specifically एक custom Stripe referral system के लिए use होता है जो मैंने PyPI package के रूप में publish किया। Package persistence के लिए PostgreSQL adapters use करके configurable reward structures के साथ referral tracking implement करता है। इसका मतलब production environment MongoDB (primary datastore) और PostgreSQL (referral subsystem) दोनों run करता है, हालांकि वे distinct purposes serve करते हैं।\n\n## Frontend Architecture\n\nदोनों React applications बिना `any` escapes के strict mode में TypeScript use करती हैं। TanStack Query proper cache invalidation, optimistic updates और error boundaries के साथ सारा server state handle करता है। Zustand persistence के साथ UI state और auth tokens manage करता है। SCSS modules CSS-in-JS runtime overhead के बिना scoped styling provide करते हैं।\n\nType safety runtime validation के through API responses तक extend होती है:\n\n```typescript\nexport const useSendChallenge = (): UseMutationResult<\n  SendChallengeResponse,\n  AxiosError,\n  SendChallengeRequest\n> => {\n  const queryClient = useQueryClient();\n  return useMutation<SendChallengeResponse, AxiosError, SendChallengeRequest>({\n    meta: { skipGlobalErrorHandler: true },\n    mutationFn: async (data: SendChallengeRequest): Promise<SendChallengeResponse> => {\n      const response = await socialMutations.sendChallenge(data);\n      if (!isValidSendChallengeResponse(response)) {\n        throw new Error(SOCIAL_ERROR_MESSAGES.INVALID_SEND_CHALLENGE_RESPONSE);\n      }\n      return response;\n    },\n    onSuccess: (): void => {\n      toast.success('Challenge sent successfully!');\n    },\n    onSettled: async (): Promise<void> => {\n      await queryClient.invalidateQueries({\n        queryKey: socialQueryKeys.challengesList(),\n        refetchType: 'active',\n      });\n    },\n    onError: createApiErrorHandler(SOCIAL_ERROR_CONTEXTS.SEND_CHALLENGE),\n  });\n};\n```\n\n`isValidSendChallengeResponse` जैसे Type guards runtime पर API responses validate करते हैं, backend contract violations को UI में propagate होने से पहले catch करते हैं। Custom error handlers debugging के लिए details log करते हुए consistent user facing error messages provide करते हैं।\n\n## Frontend WebSocket Integration\n\nSocket layer singleton client और typed hooks के साथ backend patterns mirror करती है:\n\n```typescript\nexport function useSocketEvent<K extends keyof SocketEventMap>(\n  event: K,\n  handler: SocketEventMap[K],\n  deps: React.DependencyList = [],\n): void {\n  const savedHandler = useRef<SocketEventMap[K]>(handler);\n  \n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    const eventHandler = ((...args: unknown[]): void => {\n      (savedHandler.current as (...args: unknown[]) => void)(...args);\n    }) as SocketEventMap[K];\n\n    socketClient.on(event, eventHandler);\n    return (): void => {\n      socketClient.off(event, eventHandler);\n    };\n  }, [event, ...deps]);\n}\n```\n\n`useSocialSocketListeners` जैसे Domain specific listeners friend requests, challenge updates, presence changes और direct messages handle करते हैं। हर event type relevant TanStack Query caches invalidate करता है, polling के बिना UI state synchronized रखता है। Socket client exponential backoff के साथ reconnection manage करता है और reconnect पर automatically re-authenticate करता है।\n\n## Learning Tools\n\nPlatform standard practice tests से परे 11 interactive learning tools include करता है। ये external API calls की बजाय local inference के लिए self hosted Ollama पर run होते हैं, costs predictable और response times fast रखते हैं। Tools flashcard generators से scenario based simulations तक range करते हैं, सभी XP और achievement systems के साथ integrated हैं।\n",
  "tech_stack": [
    "Python",
    "Flask",
    "Flask-RESTX",
    "Pydantic",
    "MongoDB",
    "MongoEngine",
    "Redis",
    "Celery",
    "PostgreSQL",
    "WebSockets",
    "uWSGI",
    "React",
    "TypeScript",
    "TanStack Query",
    "Zustand",
    "SCSS",
    "React Native",
    "Expo",
    "Docker",
    "Nginx",
    "GitHub Actions",
    "Cloudflare Tunnels"
  ],
  "code_snippet": "class GetUserResponse(BaseModel):\n    \"\"\"Response schema for GET /account/user\"\"\"\n    id: str = Field(..., alias=\"_id\", description=\"User ID\")\n    username: str = Field(..., description=\"Username\")\n    email: str = Field(..., description=\"Email address\")\n    coins: float = Field(..., description=\"Coin balance\")\n    xp: float = Field(..., description=\"XP points\")\n    level: int = Field(..., description=\"Current level\")\n    achievements: list[str] = Field(..., description=\"Achievement IDs\")\n    achievement_counters: dict[str, Any] | None = Field(..., description=\"Achievement counters\")\n    currentAvatar: str | None = Field(..., description=\"Equipped avatar ID\")\n    nameColor: str | None = Field(..., description=\"Name color\")\n    xpBoost: float = Field(..., description=\"XP boost multiplier\")\n    purchasedItems: list[str] = Field(..., description=\"Purchased item IDs\")\n    subscriptionActive: bool = Field(..., description=\"Subscription active\")\n    subscriptionType: str = Field(..., description=\"Subscription type\")\n    subscriptionPlan: str = Field(..., description=\"Subscription plan\")\n    subscriptionStatus: str | None = Field(..., description=\"Subscription status\")\n    subscriptionPlatform: str | None = Field(..., description=\"Platform (stripe/apple)\")\n    current_streak: int = Field(..., description=\"Current daily streak\")\n    longest_streak: int = Field(..., description=\"Longest streak ever\")\n    streak_freeze_count: int = Field(..., description=\"Freezes used this month\")\n    streak_milestones_claimed: list[int] = Field(..., description=\"Claimed milestones\")\n    current_role: str = Field(..., description=\"Role name based on level\")\n    next_role: dict[str, str | int] | None = Field(..., description=\"Next role info\")\n    referralCodeUsed: str | None = Field(..., description=\"Referral code used\")\n    referredBy: str | None = Field(..., description=\"Referrer user ID\")\n    stripeCustomerId: str | None = Field(..., description=\"Stripe customer ID\")\n    stripeSubscriptionId: str | None = Field(..., description=\"Stripe subscription ID\")\n    appleTransactionId: str | None = Field(..., description=\"Apple transaction ID\")\n    stripeConnectAccountId: str | None = Field(..., description=\"Stripe Connect ID\")\n    stripeConnectOnboarded: bool = Field(..., description=\"Connect onboarding done\")\n    stripeConnectPayoutsEnabled: bool = Field(..., description=\"Payouts enabled\")\n    # ... 40+ additional fields for auth, tracking, payments, social",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/CertGames-Core/blob/prod/backend/api/domains/account/schemas/responses.py",
  "github_url": "https://github.com/CarterPerez-dev/CertGames-Core",
  "demo_url": "https://certgames.com",
  "website_url": null,
  "docs_url": "https://certgames.com/api/docs/",
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": "https://apps.apple.com/us/app/comptia-certgames-exam-prep/id6743811522",
  "android_url": null,
  "forks_count": null,
  "display_order": 0,
  "is_complete": true,
  "status": "active",
  "start_date": "2025-10-01",
  "end_date": null,
  "is_featured": true,
  "stars_count": 7,
  "users_count": 1000,
  "downloads_count": 400,
  "banner_url": "project-certgames/banner.webp",
  "thumbnail_url": "project-certgames/thumbnail.webp",
  "screenshots": [
    "project-certgames/screenshot1.webp",
    "project-certgames/screenshot2.webp",
    "project-certgames/screenshot3.webp"
  ]
}
