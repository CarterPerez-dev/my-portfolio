{
  "slug": "fastapi-rc",
  "language": "hi",
  "title": "fastapi-rc",
  "subtitle": "FastAPI के लिए Redis caching बिना decorator magic के",
  "description": "FastAPI के लिए एक three-tier Redis caching library जो आपको direct client access, एक generic service wrapper, और custom domain caches देती है जो FastAPI के dependency injection के साथ integrate होते हैं। उन developers के लिए बनाई गई जो caching behavior पर granular control चाहते हैं बजाय opinionated decorators के।",
  "technical_details": "Library तीन abstraction levels के around structured है जिन्हें आप freely mix कर सकते हैं। सबसे नीचे, आपको FastAPI के DI system के through raw async Redis client मिलता है। एक layer ऊपर, CacheService common patterns wrap करता है जैसे cache-aside, TTL management, और serialization। सबसे ऊपर, आप typed per-domain caches dependencies के रूप में define करते हैं। इससे आप pipelines या Lua scripts के लिए raw Redis पर drop down कर सकते हैं जबकि 90% operations के लिए service layer use करते रहें।\n\n```python\n# एक endpoint में तीनों levels\n@router.post(\"/orders\")\nasync def create_order(\n    user_cache: UserCache,        # Domain-specific CacheService\n    product_cache: ProductCache,  # Another domain cache\n    redis: RedisClient,           # Custom ops के लिए Raw client\n):\n    user = await user_cache.get_or_set(user_id, factory=fetch_user)\n    async with redis.pipeline() as pipe:  # Batch के लिए raw पर drop\n        ...\n```\n\nCacheService Pydantic models पर generic है, तो `CacheService[User]` actually cached data को validate और deserialize करके User instances में वापस करता है। Serialization path check करता है कि value एक BaseModel है और `model_dump_json()` call करता है, otherwise standard JSON encoding पर fall back करता है। Read पर, अगर model type configured है, तो cached string पर `model_validate_json()` run करता है। यह schema drift को early catch करता है बजाय downstream में blow up होने के जब आप ऐसा attribute access करें जो अब exist नहीं करता।\n\n```python\nclass CacheService(Generic[T]):\n    def __init__(\n        self,\n        redis: Redis,\n        namespace: str,\n        model: type[T] | None = None,  # Optional Pydantic model\n        default_ttl: int = 300,\n        use_jitter: bool = True,\n        prefix: str = \"cache\",\n        version: str = \"v1\",\n    ): ...\n```\n\nCache keys deterministically generate होती हैं collision resistance के साथ। Format है `{prefix}:{version}:{namespace}:{identifier}` एक optional param hash append के साथ। जब आप `get_or_set` को query parameters pass करते हैं, वो sorted keys के साथ JSON serialize होते हैं, फिर 12 characters तक SHA256 hash होते हैं। इसका मतलब `get_or_set(\"list\", params={\"page\": 1, \"category\": \"electronics\"})` dict ordering की परवाह किए बिना stable key produce करता है। Version segment specifically deployments के दौरान cache invalidation के लिए exist करता है।\n\n```python\ndef build_cache_key(\n    namespace: str,\n    identifier: str,\n    params: dict[str, Any] | None = None,\n    prefix: str = \"cache\",\n    version: str = \"v1\",\n) -> str:\n    parts = [prefix, version, namespace, identifier]\n    if params:\n        param_str = json.dumps(params, sort_keys=True)\n        param_hash = hashlib.sha256(param_str.encode()).hexdigest()[:12]\n        parts.append(param_hash)\n    return \":\".join(parts)\n```\n\nTTL jitter default से on है क्योंकि cache stampedes एक real problem है जिसे ज्यादातर tutorials ignore करते हैं। जब एक हज़ार requests एक साथ expired popular key hit करती हैं, वो सब cache miss करती हैं और आपके database को slam करती हैं। `get_ttl_with_jitter` function random variance add करता है (default 10%) expiration times spread करने के लिए। एक 300 second TTL 270 से 330 seconds के बीच कुछ बन जाता है। `get_or_set` में cache-aside pattern के साथ combine करके, यह आपकी hot keys में synchronized expiration prevent करता है।\n\n```python\ndef get_ttl_with_jitter(base_ttl: int, jitter_percent: float = 0.1) -> int:\n    jitter = int(base_ttl * jitter_percent)\n    return base_ttl + random.randint(-jitter, jitter)\n```\n\nConnection management redis-py का async connection pool retry logic baked in के साथ use करता है। Retry strategy है `ExponentialWithJitterBackoff` 10 seconds पर capped, specifically ConnectionError, TimeoutError, और BusyLoadingError handle करती है। Pattern invalidation KEYS की जगह SCAN use करती है क्योंकि KEYS large keyspaces पर Redis server को block करता है। `invalidate_pattern` method `scan_iter` के साथ iterate करती है और matches individually delete करती है। यह single KEYS + DEL से slower है पर आपके production Redis को 30 seconds के लिए freeze नहीं करेगी।",
  "tech_stack": [
    "Python 3.12",
    "FastAPI",
    "Redis",
    "Pydantic v2",
    "hiredis",
    "redis-py async"
  ],
  "github_url": "https://github.com/CarterPerez-dev/fastapi-rc",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": "https://pypi.org/project/fastapi-rc/",
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "class CacheService(Generic[T]):\n    \"\"\"\n    Generic caching service for Pydantic models\n    Provides cache-aside pattern with automatic serialization\n    \"\"\"\n    def __init__(\n        self,\n        redis: Redis,\n        namespace: str,\n        model: type[T] | None = None,\n        default_ttl: int = 300,\n        use_jitter: bool = True,\n        prefix: str = \"cache\",\n        version: str = \"v1\",\n    ):\n        self.redis = redis\n        self.namespace = namespace\n        self.model = model\n        self.default_ttl = default_ttl\n        self.use_jitter = use_jitter\n        self.prefix = prefix\n        self.version = version\n\n    async def get_or_set(\n        self,\n        identifier: str,\n        factory: Callable[[], Awaitable[T]],\n        ttl: int | None = None,\n        params: dict[str, Any] | None = None,\n    ) -> T:\n        \"\"\"\n        Cache-aside pattern: get from cache or execute factory and cache result\n        \"\"\"\n        cached = await self.get(identifier, params)\n        if cached is not None:\n            return cached\n\n        value = await factory()\n        await self.set(identifier, value, ttl, params)\n        return value",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/fastapi-rc/blob/main/fastapi_rc/service.py",
  "thumbnail_url": null,
  "banner_url": null,
  "screenshots": null,
  "stars_count": 3,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": false,
  "status": "active",
  "start_date": "2025-12-13",
  "end_date": null
}
