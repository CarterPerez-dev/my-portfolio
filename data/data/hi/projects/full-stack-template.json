{
  "slug": "fullstack-template",
  "language": "hi",
  "title": "Full Stack Template",
  "subtitle": "मेरे लिए कॉपी करने के लिए बनाया गया। सीधे दिलचस्प समस्याओं पर पहुंचता है।",
  "description": "FastAPI + React एप्लिकेशन के लिए पर्सनल बॉयलरप्लेट। टोकन रोटेशन के साथ JWT auth, async PostgreSQL, दोनों तरफ टाइप सेफ्टी, Docker सेटअप, और Nginx कॉन्फिग। वो सब कुछ जिसे बार-बार बनाते-बनाते थक गया था।",
  "technical_details": "पर्सनल बॉयलरप्लेट जो मैंने बार-बार एक ही समस्याएं हल करना बंद करने के लिए बनाया। हर प्रोजेक्ट को auth, database migrations, Docker config, और type safety चाहिए। यह सब एक बार करता है ताकि मैं सीधे असली दिलचस्प काम पर जा सकूं।\n\n## SafeEnum: Values स्टोर करना, Names नहीं\n\nSQLAlchemy में एक footgun है जिसके बारे में ज्यादातर लोगों को तब तक पता नहीं चलता जब तक यह काट नहीं लेता। डिफ़ॉल्ट रूप से, यह database में enum NAMES स्टोर करता है, values नहीं। `Color.RED` को `Color.LEGACY_RED` में rename करें और अचानक आपकी पूरी table unreadable हो जाती है क्योंकि database में अभी भी `RED` स्टोर है और SQLAlchemy इसे वापस map नहीं कर पाता।\n\nफिक्स है `values_callable` actual values स्टोर करने के लिए, साथ ही एक `unknown_value` fallback ताकि नया code पुराना data पढ़ सके (या उल्टा) बिना crash हुए:\n\n```python\nclass SafeEnum(sa.Enum):\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = lambda e: [str(i.value) for i in e]\n        super().__init__(*enums, **kw)\n        self._unknown_value = kw.get(\"unknown_value\")\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise\n```\n\nअब enum member renames safe refactors हैं, database migrations नहीं।\n\n## Timing-Safe Password Verification\n\nLogin endpoints response time के through information leak करते हैं। अगर आप early return करते हैं जब user exist नहीं करता, attackers valid emails enumerate कर सकते हैं requests कितनी देर लेती हैं measure करके। फिक्स है हमेशा same amount of work करना:\n\n```python\nDUMMY_HASH = password_hasher.hash(\"dummy_password_for_timing_attack_prevention\")\n\nasync def verify_password_with_timing_safety(\n    plain_password: str,\n    hashed_password: str | None,\n) -> tuple[bool, str | None]:\n    if hashed_password is None:\n        # User exist नहीं करता, फिर भी argon2 work करो\n        await asyncio.to_thread(password_hasher.verify, plain_password, DUMMY_HASH)\n        return False, None\n    return await verify_password(plain_password, hashed_password)\n```\n\nEmail exist करे या न करे, response same time लेता है। argon2 params upgrade होने पर automatic rehashing भी handle करता है।\n\n## Token Family Tracking\n\nRefresh tokens चोरी होते हैं। सवाल है कि जब होते हैं तब क्या होता है। ज्यादातर implementations बस check करते हैं कि token valid है या नहीं। यह वाला token families track करता है:\n\n```python\nif stored_token.is_revoked:\n    # Revoked token reuse हुआ। यह replay attack है।\n    # पूरी family को खत्म करो।\n    await RefreshTokenRepository.revoke_family(\n        self.session,\n        stored_token.family_id\n    )\n    raise TokenRevokedError()\n\n# Normal rotation: current revoke करो, same family_id के साथ नया issue करो\nawait RefreshTokenRepository.revoke_token(self.session, stored_token)\nnew_token = create_refresh_token(user.id, stored_token.family_id)\n```\n\nजब आप refresh करते हैं, पुराना token revoke होता है और same `family_id` के साथ नया issue होता है। अगर कोई revoked token use करने की कोशिश करता है (attacker stolen token replay कर रहा है), पूरी family खत्म हो जाती है। Legitimate user logout हो जाता है, attacker को कुछ नहीं मिलता।\n\n## Frontend Request Queuing\n\nMultiple API calls एक साथ 401 hit कर सकते हैं। Coordination के बिना, हर एक independently token refresh करने की कोशिश करता है, race conditions और wasted requests cause करता है। Interceptor सब कुछ एक single refresh के पीछे queue करता है:\n\n```typescript\nif (isRefreshing) {\n  // दूसरी request पहले से refresh कर रही है। इसे queue करो।\n  return new Promise((resolve, reject) => {\n    addRefreshSubscriber(\n      (newToken) => {\n        originalRequest.headers.Authorization = `Bearer ${newToken}`\n        resolve(apiClient(originalRequest))\n      },\n      (error) => reject(error)\n    )\n  })\n}\n\n// पहली fail होने वाली request refresher बनती है\nisRefreshing = true\nconst newToken = await handleTokenRefresh()\nprocessRefreshQueue(null, newToken)  // सभी queued requests को unblock करो\n```\n\nएक refresh, सभी pending requests को नया token मिलता है और automatically retry होती हैं।\n\n## Zod as API Contract\n\nTypeScript types runtime पर गायब हो जाते हैं। Backend garbage return कर सकता है और `as UserResponse` खुशी से accept कर लेगा। Zod schemas runtime पर validate करते हैं और types infer करते हैं:\n\n```typescript\nexport const isValidUserResponse = (data: unknown): data is UserResponse => {\n  const result = userResponseSchema.safeParse(data)\n  return result.success\n}\n\n// Usage\nconst data: unknown = response.data\nif (!isValidUserResponse(data)) {\n  throw new UserResponseError('Invalid response', endpoint)\n}\n// data अब UserResponse के रूप में typed है\n```\n\nFrontend backend पर trust नहीं करता। हर API response use होने से पहले validate होता है।\n\n## Rust Toolchain\n\nDev tooling Rust पर चलती है। Ideological reasons से नहीं, बस इसलिए कि measurably faster है:\n\n- **uv** pip और venv को replace करता है। `uv sync` एक second से कम में `.venv` create करता है और dependencies install करता है।\n- **ruff** pylint और flake8 को replace करता है। Linting milliseconds में होती है।\n- **ty** Astral का mypy replacement है (December 2025, pre-1.0 पर usable)। Same speed story।\n- **pnpm**: npm को replace करता है। **content addressable storage** use करता है dependencies को single global store से link करने के लिए, gigabytes of disk space बचाता है और installs near instant बनाता है।\n- **biome** eslint और prettier को replace करता है। एक pass में formatting और linting, instantly।\n\nआपको किसी भी linting या package management operation के लिए एक second से ज्यादा wait नहीं करना पड़ेगा।\n\n## Everything Else\n\nDual engine setup के साथ Async SQLAlchemy 2.0 (runtime के लिए async, same connection string से Alembic migrations के लिए sync)। Password hashing के लिए Argon2id। Optimized layer caching के साथ Docker Compose। WebSocket upgrade handling और latency debugging के लिए timed logging के साथ Nginx। SCSS design tokens। Persistence के साथ Zustand stores। Codebase में कहीं भी magic strings या numbers नहीं।",
  "tech_stack": [
    "FastAPI",
    "SQLAlchemy",
    "PostgreSQL",
    "React",
    "TypeScript",
    "Zod",
    "Docker",
    "Nginx",
    "uv",
    "ruff",
    "pnpm",
    "biome"
  ],
  "github_url": "https://github.com/CarterPerez-dev/fullstack-template",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "def enum_values_callable(enum_class: type[Enum]) -> list[str]:\n    \"\"\"\n    Returns enum VALUES (not names) for SQLAlchemy storage\n\n    Prevents the common trap where SQLAlchemy stores enum NAMES by default,\n    causing database breakage if you rename an enum member\n    \"\"\"\n    return [str(item.value) for item in enum_class]\n\n\nclass SafeEnum(sa.Enum):\n    \"\"\"\n    SQLAlchemy Enum type that stores VALUES and handles unknown values gracefully\n    \"\"\"\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = enum_values_callable\n        super().__init__(*enums, **kw)\n        self._unknown_value = (\n            kw[\"_adapted_from\"]._unknown_value\n            if \"_adapted_from\" in kw else kw.get(\"unknown_value\")\n        )\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/fullstack-template/blob/main/backend/app/core/enums.py",
  "thumbnail_url": "project-full-stack-template/thumbnail.webp",
  "banner_url": "project-full-stack-template/banner.webp",
  "screenshots": null,
  "stars_count": 42,
  "forks_count": 2,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": true,
  "status": "active",
  "start_date": "2025-12-11",
  "end_date": null
}
