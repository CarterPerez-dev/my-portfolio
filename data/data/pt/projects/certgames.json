{
  "slug": "certgames",
  "language": "pt",
  "title": "CertGames",
  "subtitle": "SaaS full stack de aprendizado gamificado com composição de middleware personalizado, multiplayer em tempo real e CI/CD de produção",
  "description": "Uma plataforma SaaS de produção para preparação gamificada de certificações de cibersegurança, com mais de 15.000 questões práticas em 14 certificações, desafios multiplayer em tempo real e um sistema de gamificação abrangente com mais de 120 níveis, conquistas e sequências diárias.",
  "technical_details": "# SaaS de Produção Construído Solo\n\nCertGames representa mais de 3.000 horas de desenvolvimento solo, escalando de um projeto paralelo para um monólito de produção servindo mais de 1.000 usuários com receita recorrente mensal real. A plataforma hospeda mais de 15.000 questões práticas em 14 certificações de cibersegurança, um motor de gamificação com 120 níveis, conquistas, sequências diárias e uma economia virtual. Este artigo foca na arquitetura e decisões de engenharia em vez de funcionalidades.\n\n## Por Que Flask em Vez de FastAPI?\n\nA resposta honesta: Flask fazia mais sentido quando isso começou como um projeto pequeno que não justificava a sobrecarga do FastAPI. Quando cresceu para um monólito, refatorar teria significado reconstruir tudo. Em vez disso, construí meu próprio equivalente ao FastAPI dentro do Flask. Decorators personalizados replicam os padrões de injeção de dependência do FastAPI, Pydantic lida com toda validação de requisição/resposta, gevent fornece patching assíncrono para I/O concorrente, e o sistema de composição de decorators oferece a mesma configuração declarativa de rotas. Neste ponto, as capacidades do framework equivalem ao FastAPI enquanto mantêm compatibilidade com o ecossistema Flask.\n\n## Arquitetura Monorepo\n\nO codebase abrange três frontends e uma única aplicação Flask que abriga dois sistemas arquiteturalmente distintos. O app voltado ao usuário (`frontend/user-app`) e o dashboard administrativo (`frontend/admin-app`) são aplicações React TypeScript separadas, ambas servidas através do Nginx com roteamento baseado em caminho. Um app iOS (`frontend/ios-app`) construído com React Native e Expo/EAS compartilha a mesma API. Enquanto o backend roda como uma instância Flask, os lados admin e usuário mantêm estruturas de rotas separadas, padrões de decorators e organizações de domínio - o sistema admin sozinho rivaliza com a maioria das aplicações standalone em escopo.\n\nA API admin sozinha demonstra a escala: mais de 20 domínios seguindo uma estrutura DDD limpa onde cada domínio contém `routes.py`, `services.py`, `queries.py`, `schemas.py`, `controllers.py` e `nsdocs.py` para documentação Swagger. Cada domínio também inclui diretórios `metadata/` documentando nuances, fluxos de dados e pontos de integração com outros domínios. O diretório `admin/models/` abriga modelos em categorias como usuários, conteúdo, analytics e moderação. Esta separação mantém a lógica admin isolada enquanto compartilha infraestrutura central.\n\n## Sistema de Composição de Decorators\n\nA camada de API usa uma pilha de decorators personalizada que compõe middleware declarativamente. Uma rota típica se parece com:\n\n```python\n@content_ns.route(\"/daily/question/answer\")\nclass DailyQuestionAnswerAPI(Resource):\n    @content_ns.doc(**SUBMIT_DAILY_ANSWER_DOC)\n    @current_app.limiter.limit(\"150/minute, 5000/hour\")\n    @SecOps(\n        RL(\"50/M\"),\n        PG(LVL=\"M\", CX=\"AU\"),\n        RS(MX=\"500KB\", MXP=15),\n        TracingGuard(\"detailed\")\n    )\n    @api_endpoint(\n        auth=True,\n        subscription=True,\n        audit=False,\n        json_body=True\n    )\n    @S(SubmitDailyAnswerRequest)\n    @G(load_daily_question)\n    @R(check_not_already_answered)\n    @CertGamesAPI(SubmitDailyAnswerResponse)\n    def post(self):\n        \"\"\"\n        Submit answer to daily question (premium)\n        \"\"\"\n        return submit_daily_question_answer(), 200\n```\n\nCada decorator lida com uma preocupação específica: `@api_endpoint` gerencia verificação de autenticação, checagens de assinatura, logging de auditoria e parsing do corpo da requisição. `@S` (Schema) valida o corpo da requisição contra um modelo Pydantic. `@G` (Getter) carrega dados necessários e injeta no objeto `g` do Flask. `@R` (Requirement) impõe regras de negócio como guards. `@CertGamesAPI` envolve a resposta em um envelope consistente com validação Pydantic. Esta composição permite que rotas declarem seus requisitos sem boilerplate.\n\n## Arquitetura de Autenticação\n\nO sistema de autenticação implementa uma cadeia de fallback de três camadas para máxima compatibilidade. Autenticação primária usa tokens JWT validados através do Flask-JWT-Extended. Se a validação JWT falhar ou não existir token, o sistema recorre à autenticação baseada em sessão verificando `session.get('userId')`. Como escape final para casos extremos como conexões WebSocket de certos clientes, o sistema aceita um header `X-User-Id`. Cada fallback registra o método de autenticação usado para debugging.\n\nTrês provedores OAuth oferecem cadastro sem senha: GitHub, Google e Apple Sign-In. Cada fluxo de provedor lida com troca de tokens, extração de dados de perfil e vinculação de contas para usuários existentes.\n\nA autenticação admin sincroniza com o sistema principal de usuários. Quando um admin faz login, o sistema valida contra a coleção User, verifica privilégios de admin e então cria uma sessão espelhada no contexto admin. Esta abordagem unificada significa que admins usam as mesmas credenciais em ambas aplicações enquanto mantêm stores de sessão separados e trilhas de auditoria.\n\n## Rate Limiting de Quatro Camadas\n\nO rate limiting opera em quatro camadas sem impacto mensurável na performance. A primeira camada é um `SecureRateLimiter` personalizado baseado em Redis que identifica clientes usando uma combinação de IP, hash do user agent e ID do usuário autenticado. Implementa períodos de penalidade para infratores reincidentes e rastreia padrões entre requisições. A segunda camada usa Flask-Limiter para limites declarativos por rota. A terceira camada é um limitador global de fallback capturando qualquer coisa que escape das regras específicas de rota. A quarta camada é rate limiting do Nginx na camada de proxy reverso, fornecendo a última linha de defesa antes das requisições chegarem à aplicação.\n\n## Funcionalidades de Plataforma Social\n\nAlém da preparação para certificação, CertGames funciona como uma plataforma social. Usuários têm perfis públicos com avatares customizáveis e cores de nome compradas através da economia virtual. O sistema de amigos suporta enviar/aceitar solicitações, ver status online e desafiar amigos para quizzes cabeça a cabeça em qualquer certificação. Um sistema de mensagens em tempo real permite comunicação direta entre amigos. Leaderboards públicos classificam usuários por XP, nível e performance específica por certificação. Estas funcionalidades sociais impulsionam engajamento e retenção além da pura funcionalidade de estudo.\n\n## Motor de Gamificação\n\nA experiência central de estudo abrange 14 certificações de cibersegurança, cada uma com 10 níveis de dificuldade variando de \"muito fácil\" a \"nuclear\" com 100 questões por nível. Dois modos existem: modo prática fornece feedback imediato após cada questão, enquanto modo exame simula exames de certificação reais com sessões cronometradas e resultados mostrados apenas ao final. Respostas corretas concedem 5 moedas e 10 XP, com boosts de XP compráveis multiplicando ganhos.\n\nA economia virtual centra-se em uma loja oferecendo avatares, cores de nome, boosts de XP e congelamentos de sequência. Usuários ganham moedas através de atividade diária, conquistas e uma Questão Diária Baseada em Performance que concede 250 moedas por resolver um cenário prático. Títulos de função progridem através de níveis como \"APT-29 II,\" \"Admiral IV,\" e finalmente \"Unit 8200\" no nível máximo, exibidos em perfis e leaderboards. Certas cores de nome desbloqueiam automaticamente em níveis de marco enquanto outras requerem compra.\n\nSequências rastreiam dias consecutivos de atividade com recompensas de marco ao longo - 7 dias, 30 dias, 90 dias, 365 dias e mais. Congelamentos de sequência comprados na loja protegem contra perder progresso. Cinquenta conquistas cobrem tudo desde responder questões até interações sociais até completar desafios. Quatro jogos interativos fornecem variedade além de quizzes padrão. Uma newsletter diária entrega dicas de estudo, conselhos de carreira, notícias de cibersegurança e análises de ferramentas de pentesting, embora usuários precisem encontrar a inscrição através de um easter egg.\n\n## Monetização e Pagamentos\n\nA plataforma opera em um modelo freemium a $9.99/mês. Usuários gratuitos acessam questões práticas diárias limitadas enquanto assinantes desbloqueiam acesso ilimitado a mais de 15.000 questões em 14 certificações, todos os níveis de dificuldade, 11 ferramentas de aprendizado, PBQs diários, jogos e funcionalidades premium. Pagamentos web processam através do Stripe com gerenciamento de assinatura, atualizações de método de pagamento e tratamento de cancelamento. Pagamentos iOS usam o sistema de Compra In-App da Apple com integração StoreKit personalizada e validação de recibo server-side em vez de soluções de terceiros como RevenueCat.\n\nUm sistema de indicação recompensa usuários com 50% de cada assinatura indicada - continuamente, não apenas no primeiro mês. O rastreamento de indicação, distribuição de recompensas e infraestrutura de pagamento vivem em um serviço separado baseado em PostgreSQL que publiquei como pacote PyPI. Pagamentos suportam múltiplos métodos incluindo PayPal, Venmo, Cash App, Zelle, transferência bancária direta e Stripe Connect para usuários que preferem pagamentos instantâneos. Handlers de webhook do Stripe e Apple gerenciam mudanças de estado de assinatura, renovações, cancelamentos e falhas de pagamento.\n\n## Arquitetura WebSocket em Tempo Real\n\nA camada WebSocket usa Flask-SocketIO com arquitetura baseada em salas. Cada usuário autenticado automaticamente entra em sua sala pessoal (`user_{id}`) ao conectar. O singleton `SocketManager` fornece uma API limpa para emitir eventos:\n\n```python\nclass SocketManager:\n    @staticmethod\n    def emit_to_user(user_id: str, event: str, data: Mapping[str, Any]) -> bool:\n        socketio = SocketManager._get_socketio()\n        if not socketio:\n            return False\n        room = SocketManager.get_user_room(user_id)\n        socketio.emit(event, data, room=room)\n        return True\n\n    @staticmethod\n    def emit_to_users(user_ids: list[str], event: str, data: Mapping[str, Any]) -> int:\n        success_count = 0\n        for user_id in user_ids:\n            if SocketManager.emit_to_user(user_id, event, data):\n                success_count += 1\n        return success_count\n```\n\nRastreamento de presença notifica amigos quando usuários ficam online/offline. Eventos de desafio enviam atualizações em tempo real conforme oponentes submetem respostas. Threads de suporte habilitam chat ao vivo entre usuários e admins com indicadores de digitação. O frontend implementa hooks correspondentes para tratamento de eventos type-safe com lógica de reconexão automática.\n\n## Estratégia de Cache\n\nRedis lida com múltiplos padrões de cache. Dados de usuário são cacheados com serialização pickle/base64 para objetos Python complexos, usando um padrão de chave `user_cache:{id}` com expiração baseada em TTL. Cache de leaderboard armazena estado anterior junto com rankings atuais, habilitando cálculos de diff eficientes para atualizações ao vivo. Invalidação de cache dispara em mutações relevantes: ganhos de XP invalidam cache de usuário e potencialmente posições de leaderboard, compras invalidam inventário, e assim por diante. A camada de cache reduz significativamente a carga no MongoDB em endpoints de alto tráfego como leaderboards e perfis de usuário.\n\n## Infraestrutura de Testes\n\nA suíte de testes inclui mais de 3.000 testes pytest alcançando 85% de cobertura de código. Testes abrangem testes unitários para lógica de negócio, testes de integração para endpoints de API e testes específicos para casos extremos no motor de gamificação. Fixtures fornecem bancos de dados de teste isolados e clientes de teste autenticados. O pipeline de CI executa a suíte completa em cada PR, bloqueando merges em qualquer falha.\n\n## Qualidade de Código e Linting\n\nCada commit passa por um gauntlet agressivo de linting: Ruff para linting Python rápido, Pylint para análise estática mais profunda, MyPy para checagem de tipos estrita, Bandit para scanning de segurança, ESLint para TypeScript/React, Stylelint para SCSS e `tsc --noEmit` para verificação de tipos do frontend. Formatação de código usa YAPF em vez de Black. YAPF oferece significativamente mais granularidade de configuração para preferências de formatação, embora requeira mais setup. A troca vale pela estilização consistente e opinativa em todo o codebase.\n\n## Pipeline CI/CD\n\nO fluxo de deploy é totalmente automatizado. Push para qualquer branch dispara GitHub Actions para criar um PR automaticamente. O PR executa jobs de lint paralelos usando estratégia de matriz em todos os linters, depois executa a suíte de testes completa. Com todas as checagens passando, o PR auto-merge para a branch prod. Um runner auto-hospedado no servidor de produção detecta o merge e dispara `deploy.yml`, que reconstrói apenas containers alterados e executa restart rolling. Webhooks do Slack notificam em cada estágio: PR criado, checagens iniciadas, checagens passaram/falharam, merge completo, deploy iniciado, deploy bem-sucedido. Todo o fluxo do push à produção leva menos de 25 minutos sem intervenção manual.\n\n## Infraestrutura e DevOps\n\nProdução roda em Docker Compose com serviços incluindo a app Flask sob uWSGI, Nginx como proxy reverso, Redis com hardening de segurança, workers Celery para tarefas em background, MongoDB, MinIO para armazenamento de objetos e Ollama para inferência LLM local. uWSGI foi escolhido sobre Gunicorn deliberadamente. Para aplicações mais simples, a facilidade de uso do Gunicorn vence. Mas nesta escala, as opções de configuração granular do uWSGI para gerenciamento de workers, roteamento de requisições e limites de recursos fornecem controle que Gunicorn não consegue igualar.\n\nCloudflare Tunnels lidam com ingress sem expor portas. Uptime Kuma monitora todos os serviços com alertas Slack. Portainer fornece UI de gerenciamento de containers. Autoheal automaticamente reinicia containers não saudáveis. O setup lida com picos de tráfego graciosamente enquanto mantém custos de infraestrutura mínimos em um único servidor.\n\nA stack também inclui PostgreSQL, usado especificamente para um sistema de indicação Stripe personalizado que publiquei como pacote PyPI. O pacote implementa rastreamento de indicação com estruturas de recompensa configuráveis, usando adaptadores PostgreSQL para persistência. Isso significa que o ambiente de produção roda tanto MongoDB (datastore primário) quanto PostgreSQL (subsistema de indicação), embora sirvam propósitos distintos.\n\n## Arquitetura Frontend\n\nAmbas aplicações React usam TypeScript em modo estrito sem escapes `any`. TanStack Query lida com todo estado de servidor com invalidação de cache adequada, atualizações otimistas e error boundaries. Zustand gerencia estado de UI e tokens de autenticação com persistência. SCSS modules fornecem estilização com escopo sem overhead runtime de CSS-in-JS.\n\nType safety se estende a respostas de API através de validação runtime:\n\n```typescript\nexport const useSendChallenge = (): UseMutationResult<\n  SendChallengeResponse,\n  AxiosError,\n  SendChallengeRequest\n> => {\n  const queryClient = useQueryClient();\n  return useMutation<SendChallengeResponse, AxiosError, SendChallengeRequest>({\n    meta: { skipGlobalErrorHandler: true },\n    mutationFn: async (data: SendChallengeRequest): Promise<SendChallengeResponse> => {\n      const response = await socialMutations.sendChallenge(data);\n      if (!isValidSendChallengeResponse(response)) {\n        throw new Error(SOCIAL_ERROR_MESSAGES.INVALID_SEND_CHALLENGE_RESPONSE);\n      }\n      return response;\n    },\n    onSuccess: (): void => {\n      toast.success('Challenge sent successfully!');\n    },\n    onSettled: async (): Promise<void> => {\n      await queryClient.invalidateQueries({\n        queryKey: socialQueryKeys.challengesList(),\n        refetchType: 'active',\n      });\n    },\n    onError: createApiErrorHandler(SOCIAL_ERROR_CONTEXTS.SEND_CHALLENGE),\n  });\n};\n```\n\nType guards como `isValidSendChallengeResponse` validam respostas de API em runtime, capturando violações de contrato do backend antes que propaguem pela UI. Handlers de erro personalizados fornecem mensagens de erro consistentes para o usuário enquanto registram detalhes para debugging.\n\n## Integração WebSocket no Frontend\n\nA camada de socket espelha padrões do backend com um cliente singleton e hooks tipados:\n\n```typescript\nexport function useSocketEvent<K extends keyof SocketEventMap>(\n  event: K,\n  handler: SocketEventMap[K],\n  deps: React.DependencyList = [],\n): void {\n  const savedHandler = useRef<SocketEventMap[K]>(handler);\n  \n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    const eventHandler = ((...args: unknown[]): void => {\n      (savedHandler.current as (...args: unknown[]) => void)(...args);\n    }) as SocketEventMap[K];\n\n    socketClient.on(event, eventHandler);\n    return (): void => {\n      socketClient.off(event, eventHandler);\n    };\n  }, [event, ...deps]);\n}\n```\n\nListeners específicos de domínio como `useSocialSocketListeners` lidam com solicitações de amizade, atualizações de desafio, mudanças de presença e mensagens diretas. Cada tipo de evento invalida caches relevantes do TanStack Query, mantendo estado da UI sincronizado sem polling. O cliente socket gerencia reconexão com backoff exponencial e re-autentica automaticamente ao reconectar.\n\n## Ferramentas de Aprendizado\n\nA plataforma inclui 11 ferramentas de aprendizado interativas além de testes práticos padrão. Estas rodam em Ollama auto-hospedado para inferência local em vez de chamadas de API externas, mantendo custos previsíveis e tempos de resposta rápidos. As ferramentas variam de geradores de flashcard a simulações baseadas em cenário, todas integradas com os sistemas de XP e conquistas.\n",
  "tech_stack": [
    "Python",
    "Flask",
    "Flask-RESTX",
    "Pydantic",
    "MongoDB",
    "MongoEngine",
    "Redis",
    "Celery",
    "PostgreSQL",
    "WebSockets",
    "uWSGI",
    "React",
    "TypeScript",
    "TanStack Query",
    "Zustand",
    "SCSS",
    "React Native",
    "Expo",
    "Docker",
    "Nginx",
    "GitHub Actions",
    "Cloudflare Tunnels"
  ],
  "code_snippet": "class GetUserResponse(BaseModel):\n    \"\"\"Response schema for GET /account/user\"\"\"\n    id: str = Field(..., alias=\"_id\", description=\"User ID\")\n    username: str = Field(..., description=\"Username\")\n    email: str = Field(..., description=\"Email address\")\n    coins: float = Field(..., description=\"Coin balance\")\n    xp: float = Field(..., description=\"XP points\")\n    level: int = Field(..., description=\"Current level\")\n    achievements: list[str] = Field(..., description=\"Achievement IDs\")\n    achievement_counters: dict[str, Any] | None = Field(..., description=\"Achievement counters\")\n    currentAvatar: str | None = Field(..., description=\"Equipped avatar ID\")\n    nameColor: str | None = Field(..., description=\"Name color\")\n    xpBoost: float = Field(..., description=\"XP boost multiplier\")\n    purchasedItems: list[str] = Field(..., description=\"Purchased item IDs\")\n    subscriptionActive: bool = Field(..., description=\"Subscription active\")\n    subscriptionType: str = Field(..., description=\"Subscription type\")\n    subscriptionPlan: str = Field(..., description=\"Subscription plan\")\n    subscriptionStatus: str | None = Field(..., description=\"Subscription status\")\n    subscriptionPlatform: str | None = Field(..., description=\"Platform (stripe/apple)\")\n    current_streak: int = Field(..., description=\"Current daily streak\")\n    longest_streak: int = Field(..., description=\"Longest streak ever\")\n    streak_freeze_count: int = Field(..., description=\"Freezes used this month\")\n    streak_milestones_claimed: list[int] = Field(..., description=\"Claimed milestones\")\n    current_role: str = Field(..., description=\"Role name based on level\")\n    next_role: dict[str, str | int] | None = Field(..., description=\"Next role info\")\n    referralCodeUsed: str | None = Field(..., description=\"Referral code used\")\n    referredBy: str | None = Field(..., description=\"Referrer user ID\")\n    stripeCustomerId: str | None = Field(..., description=\"Stripe customer ID\")\n    stripeSubscriptionId: str | None = Field(..., description=\"Stripe subscription ID\")\n    appleTransactionId: str | None = Field(..., description=\"Apple transaction ID\")\n    stripeConnectAccountId: str | None = Field(..., description=\"Stripe Connect ID\")\n    stripeConnectOnboarded: bool = Field(..., description=\"Connect onboarding done\")\n    stripeConnectPayoutsEnabled: bool = Field(..., description=\"Payouts enabled\")\n    # ... 40+ additional fields for auth, tracking, payments, social",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/CertGames-Core/blob/prod/backend/api/domains/account/schemas/responses.py",
  "github_url": "https://github.com/CarterPerez-dev/CertGames-Core",
  "website_url": "https://certgames.com",
  "demo_url": null,
  "docs_url": "https://certgames.com/api/docs/",
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": "https://apps.apple.com/us/app/comptia-certgames-exam-prep/id6743811522",
  "android_url": null,
  "forks_count": null,
  "display_order": 0,
  "is_complete": true,
  "status": "active",
  "start_date": "2025-10-01",
  "end_date": null,
  "is_featured": true,
  "stars_count": 7,
  "users_count": 1000,
  "downloads_count": 400,
  "banner_url": "project-certgames/banner.webp",
  "thumbnail_url": "project-certgames/thumbnail.webp",
  "screenshots": [
    "project-certgames/screenshot1.webp",
    "project-certgames/screenshot2.webp",
    "project-certgames/screenshot3.webp"
  ]
}
