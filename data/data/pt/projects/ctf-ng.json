{
  "slug": "cisa-presidents-cup-ctf",
  "language": "pt",
  "title": "Plataforma CTF President's Cup CISA",
  "subtitle": "Backend de plataforma CTF distribuída com pontuação em tempo real e coordenação WebSocket multi-container",
  "description": "Contribuidor core backend para a plataforma de competição anual President's Cup de cibersegurança da CISA. Projetei e implementei a arquitetura fundamental incluindo sistema de notificação em tempo real, engine de pontuação, ticketing de suporte, e os padrões de middleware adotados através do codebase. A plataforma lida com usuários concorrentes através de containers Flask distribuídos em um deployment Docker Swarm.",
  "technical_details": "## O Problema de Coordenação Distribuída\n\nA plataforma roda múltiplos containers Flask atrás de um load balancer. Implementações WebSocket padrão quebram nessa configuração porque salas Flask-SocketIO são in-memory por processo. Se Usuário A conecta ao Container 1 e Usuário B conecta ao Container 2, eles não podem se comunicar através de salas. Toda feature em tempo real (atualizações de leaderboard, notificações de pontuação, respostas de ticket de suporte) precisava de uma solução que funcionasse através de limites de container.\n\n## Redis Pub/Sub como Camada de Coordenação\n\nA solução: cada container mantém sua própria tabela de lookup mapeando IDs de usuário para IDs de sessão socket. Quando uma notificação dispara, publica em um canal Redis. Todo container recebe a mensagem, verifica \"este usuário está conectado a mim?\", e só emite se tiver uma conexão ativa. Sem broadcasts desperdiçados, sem gerenciamento de sala cross-container.\n\n```python\ndef _handle_notification_message(self, message):\n    user_ids = message.get('user_ids', [])\n    event_name = message.get('event_name')\n    data = message.get('data')\n\n    for user_id in user_ids:\n        user_sids = get_user_connections(user_id)  # Lookup local apenas\n        for sid in user_sids:\n            self.socketio.emit(event_name, data, to=sid)\n```\n\nO dict `user_connections` é por-container. Redis lida com o broadcast, cada container lida com seus próprios usuários. Separação limpa.\n\n## O Bug de Threading do Gunicorn\n\nEm desenvolvimento, tudo funcionava. Em produção com workers gevent do Gunicorn, a thread subscriber Redis morreria silenciosamente. Dois problemas compostos: modelo pre-fork do Gunicorn destrói threads iniciadas durante inicialização da app, e timing de monkey patching do gevent difere entre dev e prod. A correção foi substituir `threading.Thread` por `socketio.start_background_task()`, que auto-seleciona `gevent.spawn()` em modo gevent. Pequena mudança, horas de debug para encontrar.\n\n## Abstraindo a Complexidade\n\nCódigo de domínio não deveria saber sobre Redis ou coordenação de container. O `NotificationService` expõe métodos simples como `broadcast_attempt_update(event_id, team_id, challenge_id)`. Por baixo dos panos resolve IDs de usuário, publica para Redis, lida com falhas graciosamente. Um colega de equipe trabalhando no controller de pontuação apenas chama o método e segue em frente.\n\n```python\n@staticmethod\ndef broadcast_attempt_update(event_id, team_id, challenge_id, question_id):\n    NotificationService._emit_refetch(\n        path=f\"/ng/events/{event_id}/challenges/{challenge_id}\",\n        team_id=team_id\n    )\n    NotificationService._emit_refetch(\n        path=f\"/ng/events/{event_id}/leaderboard\",\n        event_id=event_id\n    )\n```\n\n## Middleware Baseado em Decoradores\n\nTodo endpoint precisa de auth, validação de input, carregamento de recurso e verificações de permissão. Escrever esse boilerplate em todo handler de rota é propenso a erro e feio. A abordagem que emergiu (através de muito feedback de PR e iteração com a equipe): decoradores composáveis que empilham limpo.\n\n```python\n@user_endpoint(json_required=True)\n@load_event(LoaderType.PARAM)\n@load_challenge(LoaderType.PARAM)\n@load_question(LoaderType.PARAM)\n@load_team_by_user_and_event()\n@check_permissions(PermissionEnum.CAN_PLAY_CHALLENGES)\ndef post(self, event_id, challenge_id, question_id,\n         event, challenge, question, team, current_user, json_data):\n    return submit_answer(event, challenge, question, team, current_user, json_data)\n```\n\nQuando o handler roda, auth está verificado, JSON está parsed, todos os modelos estão carregados, permissões estão checadas. O handler apenas faz lógica de negócio. Esse padrão se espalhou pelo backend inteiro. Loaders de recurso para events, teams, tickets, scores. Decoradores de permissão. Validadores de ownership. Todos composáveis.\n\n## Framework de Validação\n\nTodo modelo precisa de validação de input com mensagens de erro consistentes. Ao invés de verificações ad-hoc espalhadas através de controllers, há um `BaseValidator` com métodos encadeáveis e um decorador `@validation_field` que lida com os padrões comuns (verificações required, handling de None, mensagens de erro amigáveis).\n\n```python\nvalidator = BaseValidator()\nvalidator.validate_string(data, \"name\", max_length=64, required=True)\nvalidator.validate_model_id(data, \"event_id\", \"Event\", required=True)\nvalidator.validate_datetime(data, \"expires_at\", allow_past=False)\nreturn validator.validate()  # Retorna dict limpo ou levanta ValidationError\n```\n\nPassagem única: valida e extrai dados parsed. O classmethod `validate()` de todo modelo usa isso. Shape de erro consistente através da API inteira.\n\n## O Que Aprendi\n\nEsta foi minha primeira vez trabalhando em algo nessa escala com uma equipe real. Os devs sênior no projeto (particularmente os lidando com DevOps, a orquestração Docker Swarm complexa, parsing de challenge, gerenciamento VNC, e mais) me ensinaram como realmente pensar sobre sistemas distribuídos, não apenas construir features. Os padrões decorator saíram de feedback de code review. O framework de validação evoluiu através de múltiplas iterações baseadas no que a equipe realmente precisava. Olhando meus PRs iniciais versus os posteriores, o crescimento é embaraçoso mas real. Enviar código que outras pessoas têm que manter muda como você o escreve.",
  "tech_stack": ["Python", "Flask", "Flask-SocketIO", "Redis", "PostgreSQL", "SQLAlchemy", "AWS SES", "AWS S3", "CTFd", "Docker Swarm", "pytest", "Nginx"],
  "github_url": "https://github.com/CyberSkyline/ctf-ng",
  "website_url": "https://presidentscup.cisa.gov/",
  "demo_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "@user_endpoint(json_required=True)\n@load_event(LoaderType.PARAM)\n@load_challenge(LoaderType.PARAM)\n@load_question(LoaderType.PARAM)\n@load_team_by_user_and_event()\n@limiter.limit(\"1 per 1 seconds\")\n@check_permissions(PermissionEnum.CAN_PLAY_CHALLENGES, \"You do not have permission to play challenges.\")\ndef post(\n    self,\n    event_id: int,\n    challenge_id: int,\n    question_id: int,\n    event,\n    challenge,\n    question,\n    team,\n    current_user: User,\n    permissions,\n    json_data,\n    **kwargs,\n):\n    result = submit_answer(\n        event=event,\n        challenge=challenge,\n        question=question,\n        team=team,\n        current_user=current_user,\n        submission=json_data.get(\"submission\", \"\"),\n    )\n    return success_response(result, status_code=201)",
  "code_language": "python",
  "code_filename": "https://github.com/CyberSkyline/ctf-ng/blob/development/backend/ng/scoring/routes/user_routes.py",
  "display_order": 0,
  "is_complete": true,
  "is_featured": true,
  "thumbnail_url": null,
  "banner_url": null,
  "screenshots": null,
  "stars_count": 3,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "status": "active",
  "start_date": "2025-05-01",
  "end_date": null
}
