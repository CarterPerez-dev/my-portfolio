{
  "slug": "fullstack-template",
  "language": "pt",
  "title": "Full Stack Template",
  "subtitle": "Construído para eu copiar. Pula direto para os problemas interessantes.",
  "description": "Boilerplate pessoal para aplicações FastAPI + React. Autenticação JWT com rotação de tokens, PostgreSQL assíncrono, type safety em ambos os lados, configuração Docker e config Nginx. Tudo que cansei de reconstruir do zero.",
  "technical_details": "Boilerplate pessoal que construí para parar de resolver os mesmos problemas. Todo projeto precisa de auth, migrações de banco de dados, config Docker e type safety. Isso faz tudo uma vez para que eu possa pular para o trabalho realmente interessante.\n\n## SafeEnum: Armazenando Valores, Não Nomes\n\nSQLAlchemy tem uma armadilha que a maioria das pessoas não conhece até que os morda. Por padrão, armazena NOMES de enum no banco de dados, não valores. Renomeie `Color.RED` para `Color.LEGACY_RED` e de repente sua tabela inteira fica ilegível porque o banco de dados ainda tem `RED` armazenado e o SQLAlchemy não consegue mapear de volta.\n\nA correção é `values_callable` para armazenar valores reais, mais um fallback `unknown_value` para que o código novo possa ler dados antigos (ou vice-versa) sem explodir:\n\n```python\nclass SafeEnum(sa.Enum):\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = lambda e: [str(i.value) for i in e]\n        super().__init__(*enums, **kw)\n        self._unknown_value = kw.get(\"unknown_value\")\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise\n```\n\nAgora renomeações de membros enum são refatorações seguras, não migrações de banco de dados.\n\n## Verificação de Senha com Proteção Temporal\n\nEndpoints de login vazam informação através do tempo de resposta. Se você retornar cedo quando um usuário não existe, atacantes podem enumerar emails válidos medindo quanto tempo as requisições levam. A correção é sempre fazer a mesma quantidade de trabalho:\n\n```python\nDUMMY_HASH = password_hasher.hash(\"dummy_password_for_timing_attack_prevention\")\n\nasync def verify_password_with_timing_safety(\n    plain_password: str,\n    hashed_password: str | None,\n) -> tuple[bool, str | None]:\n    if hashed_password is None:\n        # Usuário não existe, mas ainda faz trabalho argon2\n        await asyncio.to_thread(password_hasher.verify, plain_password, DUMMY_HASH)\n        return False, None\n    return await verify_password(plain_password, hashed_password)\n```\n\nSeja o email existente ou não, a resposta leva o mesmo tempo. Também lida com rehashing automático quando os parâmetros argon2 são atualizados.\n\n## Rastreamento de Família de Tokens\n\nTokens de refresh são roubados. A questão é o que acontece quando são. A maioria das implementações apenas verifica se o token é válido. Esta rastreia famílias de tokens:\n\n```python\nif stored_token.is_revoked:\n    # Token revogado foi reutilizado. Isso é um ataque de replay.\n    # Nukeia toda a família.\n    await RefreshTokenRepository.revoke_family(\n        self.session,\n        stored_token.family_id\n    )\n    raise TokenRevokedError()\n\n# Rotação normal: revoga atual, emite novo com mesmo family_id\nawait RefreshTokenRepository.revoke_token(self.session, stored_token)\nnew_token = create_refresh_token(user.id, stored_token.family_id)\n```\n\nQuando você atualiza, o token antigo é revogado e um novo é emitido com o mesmo `family_id`. Se alguém tentar usar um token revogado (atacante replicando um token roubado), toda a família é nukiada. Usuário legítimo é deslogado, atacante não ganha nada.\n\n## Enfileiramento de Requisições no Frontend\n\nVárias chamadas de API podem atingir 401 ao mesmo tempo. Sem coordenação, cada uma tenta atualizar o token independentemente, causando race conditions e requisições desperdiçadas. O interceptor enfileira tudo atrás de um único refresh:\n\n```typescript\nif (isRefreshing) {\n  // Outra requisição já está atualizando. Enfileira esta.\n  return new Promise((resolve, reject) => {\n    addRefreshSubscriber(\n      (newToken) => {\n        originalRequest.headers.Authorization = `Bearer ${newToken}`\n        resolve(apiClient(originalRequest))\n      },\n      (error) => reject(error)\n    )\n  })\n}\n\n// Primeira requisição a falhar torna-se o refresher\nisRefreshing = true\nconst newToken = await handleTokenRefresh()\nprocessRefreshQueue(null, newToken)  // Desbloqueia todas as requisições enfileiradas\n```\n\nUm refresh, todas as requisições pendentes pegam o novo token e retentam automaticamente.\n\n## Zod como Contrato de API\n\nTipos TypeScript desaparecem em runtime. O backend poderia retornar lixo e `as UserResponse` aceitaria felizmente. Schemas Zod validam em runtime e inferem os tipos:\n\n```typescript\nexport const isValidUserResponse = (data: unknown): data is UserResponse => {\n  const result = userResponseSchema.safeParse(data)\n  return result.success\n}\n\n// Uso\nconst data: unknown = response.data\nif (!isValidUserResponse(data)) {\n  throw new UserResponseError('Invalid response', endpoint)\n}\n// data agora está tipado como UserResponse\n```\n\nFrontend não confia no backend. Toda resposta de API é validada antes do uso.\n\n## Toolchain Rust\n\nAs ferramentas de dev rodam em Rust. Não por razões ideológicas, apenas porque é mensuravelmente mais rápido:\n\n- **uv** substitui pip e venv. `uv sync` cria `.venv` e instala dependências em menos de um segundo.\n- **ruff** substitui pylint e flake8. Linting acontece em milissegundos.\n- **ty** é o substituto do mypy pela Astral (Dezembro 2025, pré-1.0 mas usável). Mesma história de velocidade.\n- **pnpm**: Substitui npm. Usa **content addressable storage** para linkar dependências de um único store global, economizando gigabytes de espaço em disco e tornando instalações quase instantâneas.\n- **biome** substitui eslint e prettier. Formatação e linting em uma passada, instantaneamente.\n\nVocê não esperará mais de um segundo para qualquer operação de linting ou gerenciamento de pacotes.\n\n## Todo o Resto\n\nSQLAlchemy 2.0 assíncrono com configuração de engine dual (async para runtime, sync para migrações Alembic da mesma connection string). Argon2id para hashing de senhas. Docker Compose com cache de layers otimizado. Nginx com handling de upgrade WebSocket e logging temporizado para debug de latência. Tokens de design SCSS. Stores Zustand com persistência. Sem magic strings ou números em lugar algum no codebase.",
  "tech_stack": [
    "FastAPI",
    "SQLAlchemy",
    "PostgreSQL",
    "React",
    "TypeScript",
    "Zod",
    "Docker",
    "Nginx",
    "uv",
    "ruff",
    "pnpm",
    "biome"
  ],
  "github_url": "https://github.com/CarterPerez-dev/fullstack-template",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "def enum_values_callable(enum_class: type[Enum]) -> list[str]:\n    \"\"\"\n    Returns enum VALUES (not names) for SQLAlchemy storage\n\n    Prevents the common trap where SQLAlchemy stores enum NAMES by default,\n    causing database breakage if you rename an enum member\n    \"\"\"\n    return [str(item.value) for item in enum_class]\n\n\nclass SafeEnum(sa.Enum):\n    \"\"\"\n    SQLAlchemy Enum type that stores VALUES and handles unknown values gracefully\n    \"\"\"\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = enum_values_callable\n        super().__init__(*enums, **kw)\n        self._unknown_value = (\n            kw[\"_adapted_from\"]._unknown_value\n            if \"_adapted_from\" in kw else kw.get(\"unknown_value\")\n        )\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/fullstack-template/blob/main/backend/app/core/enums.py",
  "thumbnail_url": "project-full-stack-template/thumbnail.webp",
  "banner_url": "project-full-stack-template/banner.webp",
  "screenshots": null,
  "stars_count": 42,
  "forks_count": 2,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": true,
  "status": "active",
  "start_date": "2025-12-11",
  "end_date": null
}
