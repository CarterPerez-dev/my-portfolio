{
  "slug": "kill-pr0cess-inc",
  "language": "pt",
  "title": "kill-pr0cess.inc",
  "subtitle": "Um showcase de performance meta: backend Rust + frontend SolidJS medindo sua própria velocidade",
  "technical_details": "A premissa é deliberadamente circular. Pegue os dois frameworks mais rápidos em seus respectivos domínios, Rust com Axum no backend e SolidJS no frontend, então construa algo cujo propósito inteiro é exibir quão rápido roda. É um website sobre si mesmo. A estética dark não é decorativa; ela remove tudo exceto os dados, as métricas, o output bruto de computação observando computação. Em algum lugar entre uma suíte de benchmark e um projeto de arte, embora chamar de qualquer um pareça perder o ponto.\n\n```rust\n#[derive(Clone)]\npub struct AppState {\n    pub db_pool: DatabasePool,\n    pub redis_client: redis::Client,\n    pub github_service: GitHubService,\n    pub fractal_service: FractalService,\n    pub performance_service: PerformanceService,\n    pub cache_service: CacheService,\n    pub config: Config,\n    pub metrics: MetricsCollector,\n}\n```\n\nA arquitetura backend segue padrões de injeção de dependência padrão. AppState guarda todo serviço que a aplicação precisa: pool de banco de dados, cliente Redis, integração GitHub, monitoramento de performance, caching. Serviços são inicializados uma vez no startup e passados através da extração de estado do Axum. O serviço fractal existe puramente para dar à CPU algo intensivo para computar, paralelizado através de cores com Rayon. Todo o resto suporta o loop central de coletar métricas sobre o sistema rodando o código que coleta as métricas.\n\n```rust\nlet system_perf = SystemPerformance {\n    cpu_usage_percent: system.global_cpu_info().cpu_usage() as f64,\n    memory_usage_percent: ((total - available) / total) * 100.0,\n    load_average_1m: system.load_average().one,\n    load_average_5m: system.load_average().five,\n    uptime_seconds: system.uptime(),\n    active_processes: system.processes().len() as u32,\n};\n```\n\nHealth checks vão mais fundo que retornar 200 OK. O endpoint testa conectividade de banco de dados, pinga Redis, valida rate limits da API GitHub, e roda um pequeno cálculo fractal para verificar que o engine funciona. Cada serviço retorna status healthy, degraded ou unhealthy com tempos de resposta. Se o rate limit do GitHub cai abaixo de 10%, o sistema se marca degraded antes de qualquer coisa realmente quebrar. As rotas de performance expõem stats de CPU, memória, disco, rede, mais métricas de nível de aplicação como taxas de acerto de cache e tamanhos de connection pool. Telemetria real, não dados mock.\n\n```typescript\nconst filteredRepositories = createMemo(() => {\n  return state.repositories.filter(repo => {\n    if (state.filters.search) {\n      const searchTerm = state.filters.search.toLowerCase();\n      const searchableText = `${repo.name} ${repo.description || ''}`;\n      if (!searchableText.includes(searchTerm)) return false;\n    }\n    if (state.filters.language && repo.language !== state.filters.language) {\n      return false;\n    }\n    return true;\n  });\n});\n```\n\nSolidJS foi escolhido especificamente porque não usa virtual DOM. Updates são cirúrgicos, mirando exatamente os nós DOM que mudaram. Os hooks como useGitHub e usePerformance envolvem stores reativos com createStore e derivam valores computados com createMemo. Quando métricas atualizam, só os números re-renderizam, não o dashboard inteiro. Combinado com respostas de API de latência quase-zero do Rust, o resultado é uma UI que parece estar renderizando antes de você pedir. O que, dado sobre o que este projeto é, parece apropriado.",
  "description": "um e nenhum são a única forma verdadeira de neutralidade porque duas coisas não são permitidas existir | lux-t",
  "tech_stack": ["Rust", "Axum", "Tokio", "SQLx", "PostgreSQL", "Redis", "SolidJS", "TypeScript", "Tailwind CSS", "Rayon", "Docker"],
  "github_url": "https://github.com/CarterPerez-dev/kill-pr0cess.inc",
  "demo_url": "https://dihydroxy.nz",
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "thumbnail_url": null,
  "banner_url": null,
  "screenshots": null,
  "code_snippet": "impl AppState {\n    pub async fn health_check(&self) -> Result<serde_json::Value> {\n        let db_status = match sqlx::query(\"SELECT 1 as test\")\n            .fetch_one(&self.db_pool)\n            .await\n        {\n            Ok(_) => \"healthy\",\n            Err(_) => \"unhealthy\",\n        };\n\n        let mut conn = self.redis_client.get_async_connection().await?;\n        let redis_status = match redis::cmd(\"PING\")\n            .query_async::<_, String>(&mut conn)\n            .await\n        {\n            Ok(_) => \"healthy\",\n            Err(_) => \"unhealthy\",\n        };\n\n        let system_info = self.performance_service.get_system_info().await?;\n\n        Ok(serde_json::json!({\n            \"status\": if db_status == \"healthy\" && redis_status == \"healthy\" { \"healthy\" } else { \"unhealthy\" },\n            \"timestamp\": chrono::Utc::now(),\n            \"services\": {\n                \"database\": db_status,\n                \"redis\": redis_status,\n                \"github_api\": \"healthy\",\n                \"fractal_engine\": \"healthy\"\n            },\n            \"system\": {\n                \"cpu_usage\": system_info[\"cpu_usage_percent\"],\n                \"memory_usage\": system_info[\"memory_usage_percent\"],\n                \"uptime_seconds\": system_info[\"uptime_seconds\"]\n            }\n        }))\n    }\n}",
  "code_language": "rust",
  "code_filename": "backend/src/lib.rs",
  "stars_count": null,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "display_order": 50,
  "is_complete": true,
  "is_featured": false,
  "status": "active",
  "start_date": "2025-06-01",
  "end_date": null
}
