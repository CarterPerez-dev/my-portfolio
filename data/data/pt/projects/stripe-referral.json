{
  "slug": "stripe-referral",
  "language": "pt",
  "title": "stripe-referral",
  "subtitle": "Pacote de indicação agnóstico de framework com adaptadores de pagamento plugáveis",
  "description": "Construí isso para o CertGames quando precisei de rastreamento de indicação com automação real de pagamentos. Não consegui encontrar um pacote existente que lidasse com o ciclo de vida completo sem estar amarrado ao Django ou algum provedor de pagamento específico, então extraí o que construí em um pacote PyPI standalone. Baseado em SQLAlchemy, funciona com qualquer framework web Python, vem com adaptadores para Stripe Connect, Wise e transferências bancárias manuais.",
  "technical_details": "O padrão adapter é a abstração central aqui. Todo provedor de pagamento implementa `PayoutAdapter` com apenas dois métodos: `send_payout` e `validate_recipient`. Adicionar suporte ao Wise significou escrever uma classe que chama a API deles, sem mudanças na camada de serviço. Os adaptadores retornam resultados TypedDict em vez de lançar exceções para falhas esperadas, então você obtém `PayoutResult(success=False, error=\"...\")` em vez de try/catch em todo lugar.\n\n```python\n# Adaptador Stripe Connect valida que a conta existe e pode receber fundos\naccount = stripe.Account.retrieve(account_id)\nif not account.payouts_enabled:\n    return RecipientValidation(valid=False, error=\"Payouts not enabled\")\n```\n\nA camada de repositório mantém queries SQLAlchemy isoladas da lógica de negócio. Cada modelo tem seu próprio repositório com métodos tipados. `ReferralTrackingRepository.get_user_earnings()` retorna um dict com valores total, pendente e pago calculados via expressões `case()` do SQLAlchemy. A camada de serviço chama repositórios e nunca toca o ORM diretamente, o que tornou testes unitários muito mais fáceis já que posso mockar na fronteira do repositório.\n\n```python\n# Camada de serviço permanece limpa, repositórios lidam com complexidade de query\nearnings = tracking_repo.get_user_earnings(user_id)\nreturn UserEarnings(total=earnings[\"total\"], pending=earnings[\"pending\"], paid=earnings[\"paid\"])\n```\n\nGeração de código de indicação usa uma combinação de `secrets.token_urlsafe` e hashing SHA256 para produzir códigos como `REF_A3F2B1_xK9mNp`. O gerador recebe um callback de checagem de colisão para que tente novamente automaticamente se um código já existir. Dez tentativas no máximo antes de lançar `CodeGenerationError`. Este padrão mantém a lógica de geração testável sem precisar de um banco de dados real em testes unitários.\n\n```python\ndef generate_unique_code(user_id: str, program_key: str, check_collision_fn) -> str:\n    for _ in range(CODE_GENERATION_RETRY_ATTEMPTS):\n        code = _generate_code_string(user_id, program_key)\n        if not check_collision_fn(code):\n            return code\n    raise CodeGenerationError(\"Failed after max attempts\")\n```\n\nA hierarquia de exceções é bem granular. Há um `StripeReferralError` base do qual tudo herda, depois erros específicos para cada modo de falha: `CodeExpiredError`, `CodeMaxUsesReachedError`, `SelfReferralError`, `PayoutAlreadyExistsError` e cerca de uma dúzia de outros. Cada exceção aceita kwargs de contexto arbitrários que são formatados na representação string. Facilita debugging quando você pode ver `CodeExpiredError: Code 'REF_ABC' expired at 2025-01-15 (code=REF_ABC, expires_at=2025-01-15)`.\n\nPydantic lida com toda validação de entrada na camada de schema. Modelos de requisição removem espaços em branco e impõem limites de comprimento antes dos dados chegarem à camada de serviço. O schema `CreateProgramRequest` valida que códigos de moeda têm exatamente 3 caracteres e os converte para maiúsculas automaticamente. Serviços recebem dados já validados e retornam resultados TypedDict, mantendo as fronteiras de API limpas. Migrations Alembic vêm com o pacote para que usuários possam rodar `alembic upgrade head` para configurar tabelas em seu banco de dados existente.",
  "tech_stack": [
    "Python",
    "SQLAlchemy",
    "Stripe Connect",
    "Pydantic",
    "Alembic",
    "PostgreSQL"
  ],
  "github_url": "https://github.com/CarterPerez-dev/stripe-referral",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": "https://pypi.org/project/stripe-referral/",
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "class PayoutAdapter(ABC):\n    @abstractmethod\n    def send_payout(\n        self,\n        user_id: str,\n        amount: float,\n        currency: str,\n        recipient_data: dict[str, Any],\n    ) -> PayoutResult:\n        \"\"\"Process a payout to the user\"\"\"\n\n    @abstractmethod\n    def validate_recipient(\n        self,\n        recipient_data: dict[str, Any]\n    ) -> RecipientValidation:\n        \"\"\"Validate recipient data before attempting payout\"\"\"",
  "code_language": "python",
  "code_filename": "src/stripe_referral/adapters/base.py",
  "banner_url": null,
  "thumbnail_url": null,
  "screenshots": null,
  "stars_count": 3,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": false,
  "status": "active",
  "start_date": "2025-11-20",
  "end_date": null
}
