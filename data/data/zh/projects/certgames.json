{
  "slug": "certgames",
  "language": "zh",
  "title": "CertGames",
  "subtitle": "全栈游戏化学习SaaS平台，具备自定义中间件组合、实时多人对战和生产级CI/CD",
  "description": "一个用于游戏化网络安全认证备考的生产级SaaS平台，涵盖14项认证的15,000+道练习题、实时多人挑战，以及包含120+等级、成就和连续登录奖励的完整游戏化系统。",
  "technical_details": "# 独立开发的生产级SaaS\n\nCertGames代表了超过3,000小时的独立开发工作，从一个副项目成长为服务1,000+用户并产生真实月度经常性收入的生产级单体应用。该平台托管了14项网络安全认证的15,000+道练习题、一个包含120个等级的游戏化引擎、成就系统、每日连续登录奖励和虚拟经济系统。本文重点介绍架构和工程决策，而非功能特性。\n\n## 为什么选择Flask而非FastAPI？\n\n诚实的答案是：当这个项目作为小型项目启动时，Flask更合理，不值得为FastAPI的额外开销买单。当它成长为单体应用时，重构意味着重建一切。相反，我在Flask内部构建了自己的FastAPI等效方案。自定义装饰器复制了FastAPI的依赖注入模式，Pydantic处理所有请求/响应验证，gevent为并发I/O提供异步补丁，装饰器组合系统提供相同的声明式路由配置。到目前为止，框架能力与FastAPI相当，同时保持了Flask生态系统的兼容性。\n\n## Monorepo架构\n\n代码库跨越三个前端和一个Flask应用程序，后者托管两个架构上不同的系统。用户应用（`frontend/user-app`）和管理后台（`frontend/admin-app`）是独立的React TypeScript应用程序，都通过Nginx基于路径的路由提供服务。使用React Native和Expo/EAS构建的iOS应用（`frontend/ios-app`）共享相同的API。虽然后端作为单个Flask实例运行，但管理端和用户端保持独立的路由结构、装饰器模式和领域组织——仅管理系统的规模就可以与大多数独立应用相媲美。\n\n仅管理API就展示了其规模：20+个领域遵循清晰的DDD结构，每个领域包含`routes.py`、`services.py`、`queries.py`、`schemas.py`、`controllers.py`和用于Swagger文档的`nsdocs.py`。每个领域还包含`metadata/`目录，记录细节、数据流和与其他领域的集成点。`admin/models/`目录托管用户、内容、分析和审核等类别的模型。这种分离使管理逻辑保持隔离，同时共享核心基础设施。\n\n## 装饰器组合系统\n\nAPI层使用自定义装饰器栈，以声明式方式组合中间件。一个典型的路由如下所示：\n\n```python\n@content_ns.route(\"/daily/question/answer\")\nclass DailyQuestionAnswerAPI(Resource):\n    @content_ns.doc(**SUBMIT_DAILY_ANSWER_DOC)\n    @current_app.limiter.limit(\"150/minute, 5000/hour\")\n    @SecOps(\n        RL(\"50/M\"),\n        PG(LVL=\"M\", CX=\"AU\"),\n        RS(MX=\"500KB\", MXP=15),\n        TracingGuard(\"detailed\")\n    )\n    @api_endpoint(\n        auth=True,\n        subscription=True,\n        audit=False,\n        json_body=True\n    )\n    @S(SubmitDailyAnswerRequest)\n    @G(load_daily_question)\n    @R(check_not_already_answered)\n    @CertGamesAPI(SubmitDailyAnswerResponse)\n    def post(self):\n        \"\"\"\n        Submit answer to daily question (premium)\n        \"\"\"\n        return submit_daily_question_answer(), 200\n```\n\n每个装饰器处理特定关注点：`@api_endpoint`管理身份验证、订阅检查、审计日志和请求体解析。`@S`（Schema）根据Pydantic模型验证请求体。`@G`（Getter）加载所需数据并注入Flask的`g`对象。`@R`（Requirement）作为守卫执行业务规则。`@CertGamesAPI`使用Pydantic验证将响应包装在一致的信封中。这种组合让路由声明其需求而无需样板代码。\n\n## 身份验证架构\n\n身份验证系统实现了三层回退链以实现最大兼容性。主要身份验证使用通过Flask-JWT-Extended验证的JWT令牌。如果JWT验证失败或不存在令牌，系统回退到基于会话的身份验证，检查`session.get('userId')`。作为某些客户端WebSocket连接等边缘情况的最终后备方案，系统接受`X-User-Id`头。每个回退都会记录使用的身份验证方法以便调试。\n\n三个OAuth提供商提供无密码注册：GitHub、Google和Apple Sign-In。每个提供商流程处理令牌交换、配置文件数据提取以及现有用户的账户关联。\n\n管理员身份验证与主用户系统同步。当管理员登录时，系统针对User集合进行验证，核实管理员权限，然后在管理员上下文中创建镜像会话。这种统一方法意味着管理员在两个应用程序中使用相同的凭据，同时维护独立的会话存储和审计跟踪。\n\n## 四层速率限制\n\n速率限制在四层运行，对性能没有可测量的影响。第一层是自定义的Redis支持的`SecureRateLimiter`，使用IP、用户代理哈希和已认证用户ID的组合来识别客户端。它为重复违规者实施惩罚期，并跨请求跟踪模式。第二层使用Flask-Limiter进行声明式的每路由限制。第三层是全局回退限制器，捕获任何通过路由特定规则的请求。第四层是反向代理级别的Nginx速率限制，在请求到达应用程序之前提供最后一道防线。\n\n## 社交平台功能\n\n除了认证备考，CertGames还作为社交平台运行。用户拥有公开个人资料，可使用通过虚拟经济购买的自定义头像和名字颜色。好友系统支持发送/接受请求、查看在线状态以及在任何认证上向好友发起一对一测验挑战。实时消息系统允许好友之间直接通信。公开排行榜按XP、等级和特定认证表现对用户进行排名。这些社交功能推动了超越纯学习功能的参与度和留存率。\n\n## 游戏化引擎\n\n核心学习体验涵盖14项网络安全认证，每项有10个难度等级，从非常简单到核弹级，每个等级100道题目。存在两种模式：练习模式在每道题后提供即时反馈，而考试模式模拟真实认证考试，采用计时会话且仅在完成时显示结果。正确答案奖励5金币和10 XP，可购买的XP加成可倍增收益。\n\n虚拟经济以商店为中心，提供头像、名字颜色、XP加成和连续登录保护卡。用户通过每日活动、成就和每日基于表现的问题（解决实操场景可获得250金币）赚取金币。角色头衔通过等级递进，如APT-29 II、Admiral IV，最终在满级时达到Unit 8200，显示在个人资料和排行榜上。某些名字颜色在里程碑等级自动解锁，而其他则需要购买。\n\n连续登录跟踪连续活动天数，并在整个过程中提供里程碑奖励——7天、30天、90天、365天等等。从商店购买的连续登录保护卡可防止丢失进度。50项成就涵盖从答题到社交互动再到完成挑战的方方面面。四个互动游戏在标准测验之外提供多样性。每日新闻通讯提供学习技巧、职业建议、网络安全新闻和渗透测试工具解析，不过用户需要通过彩蛋找到订阅入口。\n\n## 变现与支付\n\n该平台采用免费增值模式，每月$9.99。免费用户可访问有限的每日练习题，而订阅用户可解锁14项认证的15,000+道题目的无限访问、所有难度等级、11种学习工具、每日PBQ、游戏和高级功能。网页支付通过Stripe处理，包括订阅管理、支付方式更新和取消处理。iOS支付使用Apple的应用内购买系统，采用自定义StoreKit集成和服务器端收据验证，而非RevenueCat等第三方解决方案。\n\n推荐系统奖励用户每个推荐订阅的50%——持续性的，不仅仅是第一个月。推荐跟踪、奖励分配和支付基础设施位于我发布为PyPI包的独立PostgreSQL支持的服务中。支付支持多种方式，包括PayPal、Venmo、Cash App、Zelle、直接银行转账，以及为偏好即时支付的用户提供的Stripe Connect。来自Stripe和Apple的Webhook处理程序管理订阅状态变更、续订、取消和支付失败。\n\n## 实时WebSocket架构\n\nWebSocket层使用Flask-SocketIO，采用基于房间的架构。每个已认证用户在连接时自动加入其个人房间（`user_{id}`）。`SocketManager`单例提供了用于发送事件的简洁API：\n\n```python\nclass SocketManager:\n    @staticmethod\n    def emit_to_user(user_id: str, event: str, data: Mapping[str, Any]) -> bool:\n        socketio = SocketManager._get_socketio()\n        if not socketio:\n            return False\n        room = SocketManager.get_user_room(user_id)\n        socketio.emit(event, data, room=room)\n        return True\n\n    @staticmethod\n    def emit_to_users(user_ids: list[str], event: str, data: Mapping[str, Any]) -> int:\n        success_count = 0\n        for user_id in user_ids:\n            if SocketManager.emit_to_user(user_id, event, data):\n                success_count += 1\n        return success_count\n```\n\n在线状态跟踪在用户上线/离线时通知好友。挑战事件在对手提交答案时推送实时更新。支持线程启用用户和管理员之间的实时聊天，带有输入指示器。前端实现了相应的hooks，用于类型安全的事件处理和自动重连逻辑。\n\n## 缓存策略\n\nRedis处理多种缓存模式。用户数据使用pickle/base64序列化缓存复杂Python对象，使用`user_cache:{id}`键模式和基于TTL的过期。排行榜缓存存储先前状态和当前排名，实现高效的差异计算以进行实时更新。缓存失效在相关变更时触发：XP增益使用户缓存失效，可能影响排行榜位置；购买使库存失效，等等。缓存层显著减少了排行榜和用户资料等高流量端点的MongoDB负载。\n\n## 测试基础设施\n\n测试套件包含3,000+ pytest测试，实现85%的代码覆盖率。测试涵盖业务逻辑的单元测试、API端点的集成测试，以及游戏化引擎边缘情况的特定测试。Fixtures提供隔离的测试数据库和已认证的测试客户端。CI流水线在每个PR上运行完整套件，任何失败都会阻止合并。\n\n## 代码质量与Linting\n\n每次提交都要通过严格的linting检查：Ruff用于快速Python linting，Pylint用于更深入的静态分析，MyPy用于严格类型检查，Bandit用于安全扫描，ESLint用于TypeScript/React，Stylelint用于SCSS，`tsc --noEmit`用于前端类型验证。代码格式化使用YAPF而非Black。YAPF为格式化偏好提供了显著更多的配置粒度，尽管需要更多设置。这种权衡对于在整个代码库中保持一致、有主见的风格是值得的。\n\n## CI/CD流水线\n\n部署流程完全自动化。推送到任何分支都会触发GitHub Actions自动创建PR。PR使用矩阵策略在所有linter上并行运行lint任务，然后执行完整测试套件。所有检查通过后，PR自动合并到prod分支。生产服务器上的自托管runner检测到合并并触发`deploy.yml`，仅重建已更改的容器并执行滚动重启。Slack webhooks在每个阶段通知：PR创建、检查开始、检查通过/失败、合并完成、部署开始、部署成功。从推送到生产的整个流程不到25分钟，无需人工干预。\n\n## 基础设施与DevOps\n\n生产环境运行在Docker Compose上，服务包括uWSGI下的Flask应用、Nginx作为反向代理、经过安全加固的Redis、用于后台任务的Celery workers、MongoDB、用于对象存储的MinIO，以及用于本地LLM推理的Ollama。选择uWSGI而非Gunicorn是经过深思熟虑的。对于更简单的应用程序，Gunicorn的易用性胜出。但在这种规模下，uWSGI对worker管理、请求路由和资源限制的细粒度配置选项提供了Gunicorn无法匹敌的控制力。\n\nCloudflare Tunnels处理入站流量而无需暴露端口。Uptime Kuma监控所有服务并通过Slack报警。Portainer提供容器管理UI。Autoheal自动重启不健康的容器。该设置在单台服务器上优雅地处理流量高峰，同时保持基础设施成本最小化。\n\n该技术栈还包括PostgreSQL，专门用于我发布为PyPI包的自定义Stripe推荐系统。该包使用PostgreSQL适配器进行持久化，实现具有可配置奖励结构的推荐跟踪。这意味着生产环境同时运行MongoDB（主数据存储）和PostgreSQL（推荐子系统），尽管它们服务于不同的目的。\n\n## 前端架构\n\n两个React应用程序都使用严格模式的TypeScript，没有`any`逃逸。TanStack Query处理所有服务器状态，具有适当的缓存失效、乐观更新和错误边界。Zustand管理UI状态和带持久化的身份验证令牌。SCSS模块提供作用域样式，没有CSS-in-JS的运行时开销。\n\n类型安全通过运行时验证扩展到API响应：\n\n```typescript\nexport const useSendChallenge = (): UseMutationResult<\n  SendChallengeResponse,\n  AxiosError,\n  SendChallengeRequest\n> => {\n  const queryClient = useQueryClient();\n  return useMutation<SendChallengeResponse, AxiosError, SendChallengeRequest>({\n    meta: { skipGlobalErrorHandler: true },\n    mutationFn: async (data: SendChallengeRequest): Promise<SendChallengeResponse> => {\n      const response = await socialMutations.sendChallenge(data);\n      if (!isValidSendChallengeResponse(response)) {\n        throw new Error(SOCIAL_ERROR_MESSAGES.INVALID_SEND_CHALLENGE_RESPONSE);\n      }\n      return response;\n    },\n    onSuccess: (): void => {\n      toast.success('Challenge sent successfully!');\n    },\n    onSettled: async (): Promise<void> => {\n      await queryClient.invalidateQueries({\n        queryKey: socialQueryKeys.challengesList(),\n        refetchType: 'active',\n      });\n    },\n    onError: createApiErrorHandler(SOCIAL_ERROR_CONTEXTS.SEND_CHALLENGE),\n  });\n};\n```\n\n类型守卫如`isValidSendChallengeResponse`在运行时验证API响应，在后端契约违规传播到UI之前捕获它们。自定义错误处理程序提供一致的面向用户的错误消息，同时记录详细信息以便调试。\n\n## 前端WebSocket集成\n\nSocket层通过单例客户端和类型化hooks镜像后端模式：\n\n```typescript\nexport function useSocketEvent<K extends keyof SocketEventMap>(\n  event: K,\n  handler: SocketEventMap[K],\n  deps: React.DependencyList = [],\n): void {\n  const savedHandler = useRef<SocketEventMap[K]>(handler);\n  \n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    const eventHandler = ((...args: unknown[]): void => {\n      (savedHandler.current as (...args: unknown[]) => void)(...args);\n    }) as SocketEventMap[K];\n\n    socketClient.on(event, eventHandler);\n    return (): void => {\n      socketClient.off(event, eventHandler);\n    };\n  }, [event, ...deps]);\n}\n```\n\n特定领域的监听器如`useSocialSocketListeners`处理好友请求、挑战更新、在线状态变化和私信。每种事件类型使相关的TanStack Query缓存失效，保持UI状态同步而无需轮询。Socket客户端使用指数退避管理重连，并在重连时自动重新认证。\n\n## 学习工具\n\n该平台包含11种超越标准练习测试的互动学习工具。这些工具在自托管的Ollama上运行本地推理，而非外部API调用，保持成本可预测且响应时间快速。工具范围从闪卡生成器到基于场景的模拟，全部与XP和成就系统集成。\n",
  "tech_stack": [
    "Python",
    "Flask",
    "Flask-RESTX",
    "Pydantic",
    "MongoDB",
    "MongoEngine",
    "Redis",
    "Celery",
    "PostgreSQL",
    "WebSockets",
    "uWSGI",
    "React",
    "TypeScript",
    "TanStack Query",
    "Zustand",
    "SCSS",
    "React Native",
    "Expo",
    "Docker",
    "Nginx",
    "GitHub Actions",
    "Cloudflare Tunnels"
  ],
  "code_snippet": "class GetUserResponse(BaseModel):\n    \"\"\"Response schema for GET /account/user\"\"\"\n    id: str = Field(..., alias=\"_id\", description=\"User ID\")\n    username: str = Field(..., description=\"Username\")\n    email: str = Field(..., description=\"Email address\")\n    coins: float = Field(..., description=\"Coin balance\")\n    xp: float = Field(..., description=\"XP points\")\n    level: int = Field(..., description=\"Current level\")\n    achievements: list[str] = Field(..., description=\"Achievement IDs\")\n    achievement_counters: dict[str, Any] | None = Field(..., description=\"Achievement counters\")\n    currentAvatar: str | None = Field(..., description=\"Equipped avatar ID\")\n    nameColor: str | None = Field(..., description=\"Name color\")\n    xpBoost: float = Field(..., description=\"XP boost multiplier\")\n    purchasedItems: list[str] = Field(..., description=\"Purchased item IDs\")\n    subscriptionActive: bool = Field(..., description=\"Subscription active\")\n    subscriptionType: str = Field(..., description=\"Subscription type\")\n    subscriptionPlan: str = Field(..., description=\"Subscription plan\")\n    subscriptionStatus: str | None = Field(..., description=\"Subscription status\")\n    subscriptionPlatform: str | None = Field(..., description=\"Platform (stripe/apple)\")\n    current_streak: int = Field(..., description=\"Current daily streak\")\n    longest_streak: int = Field(..., description=\"Longest streak ever\")\n    streak_freeze_count: int = Field(..., description=\"Freezes used this month\")\n    streak_milestones_claimed: list[int] = Field(..., description=\"Claimed milestones\")\n    current_role: str = Field(..., description=\"Role name based on level\")\n    next_role: dict[str, str | int] | None = Field(..., description=\"Next role info\")\n    referralCodeUsed: str | None = Field(..., description=\"Referral code used\")\n    referredBy: str | None = Field(..., description=\"Referrer user ID\")\n    stripeCustomerId: str | None = Field(..., description=\"Stripe customer ID\")\n    stripeSubscriptionId: str | None = Field(..., description=\"Stripe subscription ID\")\n    appleTransactionId: str | None = Field(..., description=\"Apple transaction ID\")\n    stripeConnectAccountId: str | None = Field(..., description=\"Stripe Connect ID\")\n    stripeConnectOnboarded: bool = Field(..., description=\"Connect onboarding done\")\n    stripeConnectPayoutsEnabled: bool = Field(..., description=\"Payouts enabled\")\n    # ... 40+ additional fields for auth, tracking, payments, social",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/CertGames-Core/blob/prod/backend/api/domains/account/schemas/responses.py",
  "github_url": "https://github.com/CarterPerez-dev/CertGames-Core",
  "demo_url": "https://certgames.com",
  "website_url": null,
  "docs_url": "https://certgames.com/api/docs/",
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": "https://apps.apple.com/us/app/comptia-certgames-exam-prep/id6743811522",
  "android_url": null,
  "forks_count": null,
  "display_order": 0,
  "is_complete": true,
  "status": "active",
  "start_date": "2025-10-01",
  "end_date": null,
  "is_featured": true,
  "stars_count": 7,
  "users_count": 1000,
  "downloads_count": 400,
  "banner_url": "project-certgames/banner.webp",
  "thumbnail_url": "project-certgames/thumbnail.webp",
  "screenshots": [
    "project-certgames/screenshot1.webp",
    "project-certgames/screenshot2.webp",
    "project-certgames/screenshot3.webp"
  ]
}
