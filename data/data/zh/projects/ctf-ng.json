{
  "slug": "cisa-presidents-cup-ctf",
  "language": "zh",
  "title": "CISA 总统杯 CTF 平台",
  "subtitle": "分布式 CTF 平台后端，具有实时计分和多容器 WebSocket 协调",
  "description": "CISA 年度总统杯网络安全竞赛平台的核心后端贡献者。设计并实现了基础架构，包括实时通知系统、计分引擎、支持工单系统，以及在整个代码库中采用的中间件模式。该平台在 Docker Swarm 部署中处理分布式 Flask 容器之间的并发用户。",
  "technical_details": "## 分布式协调问题\n\n该平台在负载均衡器后面运行多个 Flask 容器。标准的 WebSocket 实现在这种设置下会失效，因为 Flask-SocketIO 的 room 是每个进程内存中的。如果用户 A 连接到容器 1，用户 B 连接到容器 2，他们无法通过 room 通信。每个实时功能（排行榜更新、计分通知、支持工单回复）都需要一个跨容器边界工作的解决方案。\n\n## Redis Pub/Sub 作为协调层\n\n解决方案：每个容器维护自己的查找表，将用户 ID 映射到 socket 会话 ID。当通知触发时，它发布到 Redis 频道。每个容器接收消息，检查「这个用户连接到我这里吗？」，只有在有活动连接时才发送。没有浪费的广播，没有跨容器 room 管理。\n\n```python\ndef _handle_notification_message(self, message):\n    user_ids = message.get('user_ids', [])\n    event_name = message.get('event_name')\n    data = message.get('data')\n\n    for user_id in user_ids:\n        user_sids = get_user_connections(user_id)  # 仅本地查找\n        for sid in user_sids:\n            self.socketio.emit(event_name, data, to=sid)\n```\n\n`user_connections` 字典是每个容器独立的。Redis 处理广播，每个容器处理自己的用户。干净的分离。\n\n## Gunicorn 线程 Bug\n\n在开发环境中，一切正常。在使用 Gunicorn 的 gevent worker 的生产环境中，Redis 订阅线程会静默死亡。两个复合问题：Gunicorn 的 pre-fork 模型会销毁在应用初始化期间启动的线程，而 gevent 的 monkey patching 时机在开发和生产之间不同。修复方法是将 `threading.Thread` 替换为 `socketio.start_background_task()`，它在 gevent 模式下自动选择 `gevent.spawn()`。小改动，花了几个小时调试才找到。\n\n## 抽象复杂性\n\n领域代码不应该知道 Redis 或容器协调。`NotificationService` 暴露简单的方法，如 `broadcast_attempt_update(event_id, team_id, challenge_id)`。在底层，它解析用户 ID，发布到 Redis，优雅地处理失败。在计分控制器上工作的队友只需调用方法然后继续。\n\n```python\n@staticmethod\ndef broadcast_attempt_update(event_id, team_id, challenge_id, question_id):\n    NotificationService._emit_refetch(\n        path=f\"/ng/events/{event_id}/challenges/{challenge_id}\",\n        team_id=team_id\n    )\n    NotificationService._emit_refetch(\n        path=f\"/ng/events/{event_id}/leaderboard\",\n        event_id=event_id\n    )\n```\n\n## 基于装饰器的中间件\n\n每个端点都需要认证、输入验证、资源加载和权限检查。在每个路由处理器中编写这些样板代码容易出错且丑陋。涌现出来的方法（通过大量 PR 反馈和与团队的迭代）：可组合的装饰器，干净地堆叠。\n\n```python\n@user_endpoint(json_required=True)\n@load_event(LoaderType.PARAM)\n@load_challenge(LoaderType.PARAM)\n@load_question(LoaderType.PARAM)\n@load_team_by_user_and_event()\n@check_permissions(PermissionEnum.CAN_PLAY_CHALLENGES)\ndef post(self, event_id, challenge_id, question_id,\n         event, challenge, question, team, current_user, json_data):\n    return submit_answer(event, challenge, question, team, current_user, json_data)\n```\n\n当处理器运行时，认证已验证，JSON 已解析，所有模型已加载，权限已检查。处理器只做业务逻辑。这个模式传遍了整个后端。事件、团队、工单、分数的资源加载器。权限装饰器。所有权验证器。全部可组合。\n\n## 验证框架\n\n每个模型都需要带有一致错误消息的输入验证。不是在控制器中散布临时检查，而是有一个带有可链式方法的 `BaseValidator` 和一个处理常见模式（必需检查、None 处理、友好错误消息）的 `@validation_field` 装饰器。\n\n```python\nvalidator = BaseValidator()\nvalidator.validate_string(data, \"name\", max_length=64, required=True)\nvalidator.validate_model_id(data, \"event_id\", \"Event\", required=True)\nvalidator.validate_datetime(data, \"expires_at\", allow_past=False)\nreturn validator.validate()  # 返回干净的 dict 或抛出 ValidationError\n```\n\n单次遍历：验证并提取解析后的数据。每个模型的 `validate()` 类方法使用这个。整个 API 中一致的错误格式。\n\n## 我学到了什么\n\n这是我第一次在这种规模上与真正的团队合作。项目中的资深开发者（特别是那些处理 DevOps、复杂的 Docker Swarm 编排、挑战解析、VNC 管理等的人）教会了我如何真正思考分布式系统，而不仅仅是构建功能。装饰器模式是从代码审查反馈中产生的。验证框架是根据团队实际需要经过多次迭代演进的。看看我早期的 PR 和后来的，成长是尴尬的但是真实的。发布其他人必须维护的代码会改变你编写它的方式。",
  "tech_stack": ["Python", "Flask", "Flask-SocketIO", "Redis", "PostgreSQL", "SQLAlchemy", "AWS SES", "AWS S3", "CTFd", "Docker Swarm", "pytest", "Nginx"],
  "github_url": "https://github.com/CyberSkyline/ctf-ng",
  "website_url": "https://presidentscup.cisa.gov/",
  "demo_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "@user_endpoint(json_required=True)\n@load_event(LoaderType.PARAM)\n@load_challenge(LoaderType.PARAM)\n@load_question(LoaderType.PARAM)\n@load_team_by_user_and_event()\n@limiter.limit(\"1 per 1 seconds\")\n@check_permissions(PermissionEnum.CAN_PLAY_CHALLENGES, \"You do not have permission to play challenges.\")\ndef post(\n    self,\n    event_id: int,\n    challenge_id: int,\n    question_id: int,\n    event,\n    challenge,\n    question,\n    team,\n    current_user: User,\n    permissions,\n    json_data,\n    **kwargs,\n):\n    result = submit_answer(\n        event=event,\n        challenge=challenge,\n        question=question,\n        team=team,\n        current_user=current_user,\n        submission=json_data.get(\"submission\", \"\"),\n    )\n    return success_response(result, status_code=201)",
  "code_language": "python",
  "code_filename": "https://github.com/CyberSkyline/ctf-ng/blob/development/backend/ng/scoring/routes/user_routes.py",
  "display_order": 0,
  "is_complete": true,
  "is_featured": true,
  "thumbnail_url": null,
  "banner_url": null,
  "screenshots": null,
  "stars_count": 3,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "status": "active",
  "start_date": "2025-05-01",
  "end_date": null
}
