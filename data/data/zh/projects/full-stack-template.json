{
  "slug": "fullstack-template",
  "language": "zh",
  "title": "Full Stack Template",
  "subtitle": "为自己构建的模板。直接跳到有趣的问题。",
  "description": "个人的 FastAPI + React 应用模板。JWT 认证带 token 轮换、异步 PostgreSQL、前后端类型安全、Docker 配置和 Nginx 配置。所有我厌倦了从头重建的东西。",
  "technical_details": "我构建这个个人模板是为了停止解决同样的问题。每个项目都需要认证、数据库迁移、Docker 配置和类型安全。这个模板一次性解决这些，让我可以直接跳到真正有趣的工作。\n\n## SafeEnum：存储值，而非名称\n\nSQLAlchemy 有一个大多数人不知道的坑，直到被它坑到。默认情况下，它在数据库中存储枚举的名称，而不是值。把 `Color.RED` 重命名为 `Color.LEGACY_RED`，突然整个表都无法读取了，因为数据库里仍然存储着 `RED`，而 SQLAlchemy 无法将其映射回来。\n\n解决方案是使用 `values_callable` 来存储实际值，再加上一个 `unknown_value` 回退，这样新代码可以读取旧数据（反之亦然）而不会崩溃：\n\n```python\nclass SafeEnum(sa.Enum):\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = lambda e: [str(i.value) for i in e]\n        super().__init__(*enums, **kw)\n        self._unknown_value = kw.get(\"unknown_value\")\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise\n```\n\n现在重命名枚举成员是安全的重构，而不是数据库迁移。\n\n## 时序安全的密码验证\n\n登录端点通过响应时间泄露信息。如果用户不存在时提前返回，攻击者可以通过测量请求耗时来枚举有效邮箱。解决方案是始终做相同量的工作：\n\n```python\nDUMMY_HASH = password_hasher.hash(\"dummy_password_for_timing_attack_prevention\")\n\nasync def verify_password_with_timing_safety(\n    plain_password: str,\n    hashed_password: str | None,\n) -> tuple[bool, str | None]:\n    if hashed_password is None:\n        # 用户不存在，但仍然执行 argon2 工作\n        await asyncio.to_thread(password_hasher.verify, plain_password, DUMMY_HASH)\n        return False, None\n    return await verify_password(plain_password, hashed_password)\n```\n\n无论邮箱是否存在，响应时间都相同。还能在 argon2 参数升级时自动处理重新哈希。\n\n## Token 家族追踪\n\nRefresh token 会被盗。问题是被盗后会发生什么。大多数实现只检查 token 是否有效。这个实现追踪 token 家族：\n\n```python\nif stored_token.is_revoked:\n    # 已撤销的 token 被重用了。这是重放攻击。\n    # 销毁整个家族。\n    await RefreshTokenRepository.revoke_family(\n        self.session,\n        stored_token.family_id\n    )\n    raise TokenRevokedError()\n\n# 正常轮换：撤销当前的，发放新的，保持相同的 family_id\nawait RefreshTokenRepository.revoke_token(self.session, stored_token)\nnew_token = create_refresh_token(user.id, stored_token.family_id)\n```\n\n当你刷新时，旧 token 被撤销，新 token 带着相同的 `family_id` 发放。如果有人试图使用已撤销的 token（攻击者重放被盗的 token），整个家族都会被销毁。合法用户被登出，攻击者什么都得不到。\n\n## 前端请求队列\n\n多个 API 调用可能同时收到 401。没有协调的话，每个调用都会独立尝试刷新 token，导致竞态条件和浪费的请求。拦截器将所有请求排队到单个刷新操作后面：\n\n```typescript\nif (isRefreshing) {\n  // 另一个请求已经在刷新了。将这个排队。\n  return new Promise((resolve, reject) => {\n    addRefreshSubscriber(\n      (newToken) => {\n        originalRequest.headers.Authorization = `Bearer ${newToken}`\n        resolve(apiClient(originalRequest))\n      },\n      (error) => reject(error)\n    )\n  })\n}\n\n// 第一个失败的请求成为刷新者\nisRefreshing = true\nconst newToken = await handleTokenRefresh()\nprocessRefreshQueue(null, newToken)  // 解除所有排队请求的阻塞\n```\n\n一次刷新，所有待处理请求都获得新 token 并自动重试。\n\n## Zod 作为 API 契约\n\nTypeScript 类型在运行时消失。后端可能返回垃圾数据，而 `as UserResponse` 会欣然接受。Zod schema 在运行时验证并推断类型：\n\n```typescript\nexport const isValidUserResponse = (data: unknown): data is UserResponse => {\n  const result = userResponseSchema.safeParse(data)\n  return result.success\n}\n\n// 使用\nconst data: unknown = response.data\nif (!isValidUserResponse(data)) {\n  throw new UserResponseError('Invalid response', endpoint)\n}\n// data 现在被类型化为 UserResponse\n```\n\n前端不信任后端。每个 API 响应在使用前都会被验证。\n\n## Rust 工具链\n\n开发工具运行在 Rust 上。不是出于意识形态原因，只是因为它明显更快：\n\n- **uv** 替代 pip 和 venv。`uv sync` 在不到一秒内创建 `.venv` 并安装依赖。\n- **ruff** 替代 pylint 和 flake8。Linting 在毫秒内完成。\n- **ty** 是 Astral 的 mypy 替代品（2025年12月，pre-1.0 但可用）。同样的速度优势。\n- **pnpm**：替代 npm。使用**内容寻址存储**从单个全局存储链接依赖，节省几个 GB 的磁盘空间，安装几乎瞬间完成。\n- **biome** 替代 eslint 和 prettier。格式化和 linting 一次完成，瞬间完成。\n\n任何 linting 或包管理操作都不会让你等超过一秒。\n\n## 其他一切\n\n异步 SQLAlchemy 2.0，带双引擎设置（异步用于运行时，同步用于从同一连接字符串运行 Alembic 迁移）。Argon2id 用于密码哈希。Docker Compose 带优化的层缓存。Nginx 带 WebSocket 升级处理和带时间戳的日志用于延迟调试。SCSS 设计令牌。带持久化的 Zustand store。代码库中没有任何魔法字符串或数字。",
  "tech_stack": [
    "FastAPI",
    "SQLAlchemy",
    "PostgreSQL",
    "React",
    "TypeScript",
    "Zod",
    "Docker",
    "Nginx",
    "uv",
    "ruff",
    "pnpm",
    "biome"
  ],
  "github_url": "https://github.com/CarterPerez-dev/fullstack-template",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "def enum_values_callable(enum_class: type[Enum]) -> list[str]:\n    \"\"\"\n    Returns enum VALUES (not names) for SQLAlchemy storage\n\n    Prevents the common trap where SQLAlchemy stores enum NAMES by default,\n    causing database breakage if you rename an enum member\n    \"\"\"\n    return [str(item.value) for item in enum_class]\n\n\nclass SafeEnum(sa.Enum):\n    \"\"\"\n    SQLAlchemy Enum type that stores VALUES and handles unknown values gracefully\n    \"\"\"\n    def __init__(self, *enums: type[Enum], **kw: Any) -> None:\n        if \"values_callable\" not in kw:\n            kw[\"values_callable\"] = enum_values_callable\n        super().__init__(*enums, **kw)\n        self._unknown_value = (\n            kw[\"_adapted_from\"]._unknown_value\n            if \"_adapted_from\" in kw else kw.get(\"unknown_value\")\n        )\n\n    def _object_value_for_elem(self, elem: str) -> Enum:\n        try:\n            return self._object_lookup[elem]\n        except LookupError:\n            if self._unknown_value is not None:\n                return self._unknown_value\n            raise",
  "code_language": "python",
  "code_filename": "https://github.com/CarterPerez-dev/fullstack-template/blob/main/backend/app/core/enums.py",
  "thumbnail_url": "project-full-stack-template/thumbnail.webp",
  "banner_url": "project-full-stack-template/banner.webp",
  "screenshots": null,
  "stars_count": 42,
  "forks_count": 2,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": true,
  "status": "active",
  "start_date": "2025-12-11",
  "end_date": null
}
