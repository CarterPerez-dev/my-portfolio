{
  "slug": "kill-pr0cess-inc",
  "language": "zh",
  "title": "kill-pr0cess.inc",
  "subtitle": "元性能展示：Rust 后端 + SolidJS 前端测量自身速度",
  "technical_details": "前提是刻意循环的。取各自领域中最快的两个框架，后端是 Rust 配 Axum，前端是 SolidJS，然后构建一个唯一目的是展示它运行有多快的东西。这是一个关于自己的网站。深色美学不是装饰性的；它剥离了除数据、指标、计算观察计算的原始输出之外的一切。介于基准测试套件和艺术项目之间的某处，尽管称它为任何一个都感觉像是错过了重点。\n\n```rust\n#[derive(Clone)]\npub struct AppState {\n    pub db_pool: DatabasePool,\n    pub redis_client: redis::Client,\n    pub github_service: GitHubService,\n    pub fractal_service: FractalService,\n    pub performance_service: PerformanceService,\n    pub cache_service: CacheService,\n    pub config: Config,\n    pub metrics: MetricsCollector,\n}\n```\n\n后端架构遵循标准的依赖注入模式。AppState 持有应用程序需要的每个服务：数据库池、Redis 客户端、GitHub 集成、性能监控、缓存。服务在启动时初始化一次，并通过 Axum 的状态提取传递。分形服务的存在纯粹是为了给 CPU 一些密集计算的东西，用 Rayon 跨核心并行化。其他一切都支持收集关于运行收集指标代码的系统的指标这个核心循环。\n\n```rust\nlet system_perf = SystemPerformance {\n    cpu_usage_percent: system.global_cpu_info().cpu_usage() as f64,\n    memory_usage_percent: ((total - available) / total) * 100.0,\n    load_average_1m: system.load_average().one,\n    load_average_5m: system.load_average().five,\n    uptime_seconds: system.uptime(),\n    active_processes: system.processes().len() as u32,\n};\n```\n\n健康检查比返回 200 OK 更深入。端点测试数据库连接、ping Redis、验证 GitHub API 速率限制，并运行一个小的分形计算来验证引擎工作。每个服务返回 healthy、degraded 或 unhealthy 状态以及响应时间。如果 GitHub 的速率限制降到 10% 以下，系统在任何东西真正崩溃之前就将自己标记为 degraded。性能路由暴露 CPU、内存、磁盘、网络统计，加上应用级指标如缓存命中率和连接池大小。真实遥测，不是模拟数据。\n\n```typescript\nconst filteredRepositories = createMemo(() => {\n  return state.repositories.filter(repo => {\n    if (state.filters.search) {\n      const searchTerm = state.filters.search.toLowerCase();\n      const searchableText = `${repo.name} ${repo.description || ''}`;\n      if (!searchableText.includes(searchTerm)) return false;\n    }\n    if (state.filters.language && repo.language !== state.filters.language) {\n      return false;\n    }\n    return true;\n  });\n});\n```\n\n选择 SolidJS 特别是因为它不使用虚拟 DOM。更新是外科手术式的，精确定位到发生变化的 DOM 节点。像 useGitHub 和 usePerformance 这样的 hook 用 createStore 包装响应式存储，用 createMemo 派生计算值。当指标更新时，只有数字重新渲染，而不是整个仪表板。结合 Rust 近乎零延迟的 API 响应，结果是一个感觉像在你问之前就渲染好的 UI。考虑到这个项目是关于什么的，这似乎很合适。",
  "description": "one and nun are the only true form of nuetrality because two things are not allowed to exist | lux-t",
  "tech_stack": ["Rust", "Axum", "Tokio", "SQLx", "PostgreSQL", "Redis", "SolidJS", "TypeScript", "Tailwind CSS", "Rayon", "Docker"],
  "github_url": "https://github.com/CarterPerez-dev/kill-pr0cess.inc",
  "demo_url": "https://dihydroxy.nz",
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": null,
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "thumbnail_url": null,
  "banner_url": null,
  "screenshots": null,
  "code_snippet": "impl AppState {\n    pub async fn health_check(&self) -> Result<serde_json::Value> {\n        let db_status = match sqlx::query(\"SELECT 1 as test\")\n            .fetch_one(&self.db_pool)\n            .await\n        {\n            Ok(_) => \"healthy\",\n            Err(_) => \"unhealthy\",\n        };\n\n        let mut conn = self.redis_client.get_async_connection().await?;\n        let redis_status = match redis::cmd(\"PING\")\n            .query_async::<_, String>(&mut conn)\n            .await\n        {\n            Ok(_) => \"healthy\",\n            Err(_) => \"unhealthy\",\n        };\n\n        let system_info = self.performance_service.get_system_info().await?;\n\n        Ok(serde_json::json!({\n            \"status\": if db_status == \"healthy\" && redis_status == \"healthy\" { \"healthy\" } else { \"unhealthy\" },\n            \"timestamp\": chrono::Utc::now(),\n            \"services\": {\n                \"database\": db_status,\n                \"redis\": redis_status,\n                \"github_api\": \"healthy\",\n                \"fractal_engine\": \"healthy\"\n            },\n            \"system\": {\n                \"cpu_usage\": system_info[\"cpu_usage_percent\"],\n                \"memory_usage\": system_info[\"memory_usage_percent\"],\n                \"uptime_seconds\": system_info[\"uptime_seconds\"]\n            }\n        }))\n    }\n}",
  "code_language": "rust",
  "code_filename": "backend/src/lib.rs",
  "stars_count": null,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "display_order": 50,
  "is_complete": true,
  "is_featured": false,
  "status": "active",
  "start_date": "2025-06-01",
  "end_date": null
}
