{
  "slug": "stripe-referral",
  "language": "zh",
  "title": "stripe-referral",
  "subtitle": "框架无关的推荐系统包，支持可插拔的支付适配器",
  "description": "这是我为 CertGames 构建的，当时需要带有实际支付自动化的推荐追踪功能。找不到现有的包能处理完整生命周期而不绑定 Django 或某个特定支付提供商，所以我把自己写的东西提取出来做成了独立的 PyPI 包。基于 SQLAlchemy，可以配合任何 Python web 框架使用，自带 Stripe Connect、Wise 和手动银行转账的适配器。",
  "technical_details": "适配器模式是这里的核心抽象。每个支付提供商实现 `PayoutAdapter`，只需要两个方法：`send_payout` 和 `validate_recipient`。添加 Wise 支持只需要写一个调用他们 API 的类，服务层完全不用改。适配器返回 TypedDict 结果而不是为预期失败抛出异常，所以你得到的是 `PayoutResult(success=False, error=\"...\")` 而不是到处写 try/catch。\n\n```python\n# Stripe Connect 适配器验证账户存在且可以接收资金\naccount = stripe.Account.retrieve(account_id)\nif not account.payouts_enabled:\n    return RecipientValidation(valid=False, error=\"Payouts not enabled\")\n```\n\n仓储层把 SQLAlchemy 查询和业务逻辑隔离开。每个模型有自己的仓储，带有类型化的方法。`ReferralTrackingRepository.get_user_earnings()` 返回一个 dict，包含通过 SQLAlchemy 的 `case()` 表达式计算的总额、待处理和已支付金额。服务层调用仓储，从不直接接触 ORM，这让单元测试容易多了，因为我可以在仓储边界进行 mock。\n\n```python\n# 服务层保持干净，仓储处理查询复杂度\nearnings = tracking_repo.get_user_earnings(user_id)\nreturn UserEarnings(total=earnings[\"total\"], pending=earnings[\"pending\"], paid=earnings[\"paid\"])\n```\n\n推荐码生成使用 `secrets.token_urlsafe` 和 SHA256 哈希的组合来生成类似 `REF_A3F2B1_xK9mNp` 的代码。生成器接受一个碰撞检查回调，如果代码已存在会自动重试。最多十次尝试，之后抛出 `CodeGenerationError`。这个模式让生成逻辑可以在单元测试中测试而不需要真实数据库。\n\n```python\ndef generate_unique_code(user_id: str, program_key: str, check_collision_fn) -> str:\n    for _ in range(CODE_GENERATION_RETRY_ATTEMPTS):\n        code = _generate_code_string(user_id, program_key)\n        if not check_collision_fn(code):\n            return code\n    raise CodeGenerationError(\"Failed after max attempts\")\n```\n\n异常层次结构相当细粒度。有一个基础的 `StripeReferralError`，所有异常都继承自它，然后是针对每种失败模式的特定错误：`CodeExpiredError`、`CodeMaxUsesReachedError`、`SelfReferralError`、`PayoutAlreadyExistsError`，还有大约十几个其他的。每个异常接受任意的上下文 kwargs，会被格式化到字符串表示中。当你能看到 `CodeExpiredError: Code 'REF_ABC' expired at 2025-01-15 (code=REF_ABC, expires_at=2025-01-15)` 时，调试会容易很多。\n\nPydantic 在 schema 层处理所有输入验证。Request 模型在数据到达服务层之前去除空白字符并强制长度限制。`CreateProgramRequest` schema 验证货币代码必须正好是3个字符并自动转换为大写。服务接收已验证的数据并返回 TypedDict 结果，保持 API 边界清晰。Alembic 迁移随包一起发布，用户可以运行 `alembic upgrade head` 在现有数据库中设置表。",
  "tech_stack": [
    "Python",
    "SQLAlchemy",
    "Stripe Connect",
    "Pydantic",
    "Alembic",
    "PostgreSQL"
  ],
  "github_url": "https://github.com/CarterPerez-dev/stripe-referral",
  "demo_url": null,
  "website_url": null,
  "docs_url": null,
  "blog_url": null,
  "pypi_url": "https://pypi.org/project/stripe-referral/",
  "npm_url": null,
  "ios_url": null,
  "android_url": null,
  "code_snippet": "class PayoutAdapter(ABC):\n    @abstractmethod\n    def send_payout(\n        self,\n        user_id: str,\n        amount: float,\n        currency: str,\n        recipient_data: dict[str, Any],\n    ) -> PayoutResult:\n        \"\"\"Process a payout to the user\"\"\"\n\n    @abstractmethod\n    def validate_recipient(\n        self,\n        recipient_data: dict[str, Any]\n    ) -> RecipientValidation:\n        \"\"\"Validate recipient data before attempting payout\"\"\"",
  "code_language": "python",
  "code_filename": "src/stripe_referral/adapters/base.py",
  "banner_url": null,
  "thumbnail_url": null, 
  "screenshots": null,
  "stars_count": 3,
  "forks_count": null,
  "downloads_count": null,
  "users_count": null,
  "display_order": 0,
  "is_complete": true,
  "is_featured": false,
  "status": "active",
  "start_date": "2025-11-20",
  "end_date": null
}
